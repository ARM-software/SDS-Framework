{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SDS-Framework This documentation explains the usage of the SDS-Framework for developing DSP, ML, or Edge AI algorithms. Target Audience This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs. Manual Chapters Overview explains the of features of the SDS-Framework and outlines the possibilities. Theory of Operation explains data stream recording and playback. SDS Interface describes the various interfaces (USB, Socket, File System) for connecting to the target. Examples lists the examples that are available. Utilities explains Python based utilities that operate with SDS data files for converting, viewing, recording, and playback. Revision History Version Description 1.1.0 Initial release for SDS-Framework 1.1.0","title":"Home"},{"location":"#sds-framework","text":"This documentation explains the usage of the SDS-Framework for developing DSP, ML, or Edge AI algorithms.","title":"SDS-Framework"},{"location":"#target-audience","text":"This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs.","title":"Target Audience"},{"location":"#manual-chapters","text":"Overview explains the of features of the SDS-Framework and outlines the possibilities. Theory of Operation explains data stream recording and playback. SDS Interface describes the various interfaces (USB, Socket, File System) for connecting to the target. Examples lists the examples that are available. Utilities explains Python based utilities that operate with SDS data files for converting, viewing, recording, and playback.","title":"Manual Chapters"},{"location":"#revision-history","text":"Version Description 1.1.0 Initial release for SDS-Framework 1.1.0","title":"Revision History"},{"location":"examples/","text":"Examples SDS examples applications are provided in a separate GitHub repository and shows the usage of the SDS-Framework. The examples use csolution project layers to simplify targeting to different hardware boards. The Sensor Layer implements a data streaming interface to is described in the section Overview . It is user code that is application specific. The Layer Type: SDS_Recorder connects the data streams to the SDS files. There are various ready to use implementations available as outlined in the table below. Several layer implementations use the MDK-Middleware for communication. Layer Type: SDS_Recorder Description SDS_Rec_Network.clayer.yml Connects via TCP/IP Network Ethernet to SDSIO Server. SDS_Rec_USB.clayer.yml Connects via USB Device VCom to SDSIO Server. SDS_Rec_FileSystem.clayer.yml Connects via FileSystem to a memory card. The Layer Type: Board is a standard board layer that provides a communication interface ( CMSIS_ETH , CMSIS_USB_Device ), a sensor interface ( I2C , SPI ), and a CMSIS_VIO interface for SDS recorder control. Other variants may have Audio or Video interfaces. Connections help to identify the compatible software layers. The CMSIS-Toolbox section Reference Applications for more information about the project structure.","title":"Examples"},{"location":"examples/#examples","text":"SDS examples applications are provided in a separate GitHub repository and shows the usage of the SDS-Framework. The examples use csolution project layers to simplify targeting to different hardware boards. The Sensor Layer implements a data streaming interface to is described in the section Overview . It is user code that is application specific. The Layer Type: SDS_Recorder connects the data streams to the SDS files. There are various ready to use implementations available as outlined in the table below. Several layer implementations use the MDK-Middleware for communication. Layer Type: SDS_Recorder Description SDS_Rec_Network.clayer.yml Connects via TCP/IP Network Ethernet to SDSIO Server. SDS_Rec_USB.clayer.yml Connects via USB Device VCom to SDSIO Server. SDS_Rec_FileSystem.clayer.yml Connects via FileSystem to a memory card. The Layer Type: Board is a standard board layer that provides a communication interface ( CMSIS_ETH , CMSIS_USB_Device ), a sensor interface ( I2C , SPI ), and a CMSIS_VIO interface for SDS recorder control. Other variants may have Audio or Video interfaces. Connections help to identify the compatible software layers. The CMSIS-Toolbox section Reference Applications for more information about the project structure.","title":"Examples"},{"location":"overview/","text":"Overview The Synchronous Data Stream (SDS) Framework implements a data stream management, provides methods and utilities for developing and optimizing embedded applications that use DSP, ML, or Edge AI algorithms. The SDS-Framework allows you to capture simultaneously multiple data streams from different sources (sensors, audio, and video inputs) or the results of algorithms in real-time directly in target hardware. These data streams are stored in files. The captured data streams are useful in various steps of the development cycle, for example to: Validate physical input signals from sensors or output of algorithms. Provide input data to Digital Signal Processing (DSP) development tools such as filter designers. Provide input data to ML/AI development systems for model classification, training, and performance optimization. Provide input data for simulation using Arm Virtual Hardware (AVH-FVP) models for testing and validation. Data Capturing and Playback The following diagram shows the data capturing in a microcontroller system using a network communication and the playback in simulation using Arm Virtual Hardware - Fixed Virtual Platform . The SDS Recorder or Playback Interface is integrated into the target application and runs on the microcontroller. It enables data streaming into SDS data files via various interfaces such as Ethernet, UART, USB, or File System. The I/O implementation included in SDS utilizes the MDK-Middleware , however custom interfaces to other middleware or different communication channels can also be used. The SDSIO Server running on a host computer captures the recorded data stream and stores it in SDS data files. Each recording creates one set of SDS data files that are indicated by a sequential number. The SDS data files are in binary format and may be described using a YAML metadata file . With this information, other tools can utilize the content of the SDS data files as shown in the picture below. In a simulation environment, the SDS Playback Interface streams the SDS data files back to the algorithm under test. With this interface, the algorithm receives the same data stream as in the physical hardware. The setup can therefore be used for validation, performance optimizations, and runs even in CI environments for test automation.","title":"Overview"},{"location":"overview/#overview","text":"The Synchronous Data Stream (SDS) Framework implements a data stream management, provides methods and utilities for developing and optimizing embedded applications that use DSP, ML, or Edge AI algorithms. The SDS-Framework allows you to capture simultaneously multiple data streams from different sources (sensors, audio, and video inputs) or the results of algorithms in real-time directly in target hardware. These data streams are stored in files. The captured data streams are useful in various steps of the development cycle, for example to: Validate physical input signals from sensors or output of algorithms. Provide input data to Digital Signal Processing (DSP) development tools such as filter designers. Provide input data to ML/AI development systems for model classification, training, and performance optimization. Provide input data for simulation using Arm Virtual Hardware (AVH-FVP) models for testing and validation.","title":"Overview"},{"location":"overview/#data-capturing-and-playback","text":"The following diagram shows the data capturing in a microcontroller system using a network communication and the playback in simulation using Arm Virtual Hardware - Fixed Virtual Platform . The SDS Recorder or Playback Interface is integrated into the target application and runs on the microcontroller. It enables data streaming into SDS data files via various interfaces such as Ethernet, UART, USB, or File System. The I/O implementation included in SDS utilizes the MDK-Middleware , however custom interfaces to other middleware or different communication channels can also be used. The SDSIO Server running on a host computer captures the recorded data stream and stores it in SDS data files. Each recording creates one set of SDS data files that are indicated by a sequential number. The SDS data files are in binary format and may be described using a YAML metadata file . With this information, other tools can utilize the content of the SDS data files as shown in the picture below. In a simulation environment, the SDS Playback Interface streams the SDS data files back to the algorithm under test. With this interface, the algorithm receives the same data stream as in the physical hardware. The setup can therefore be used for validation, performance optimizations, and runs even in CI environments for test automation.","title":"Data Capturing and Playback"},{"location":"sds_interface/","text":"SDS Interface The SDSIO components offer flexible recorder and playback interfaces. You may choose between these interface components that can be easily integrated into the target system: - component: SDS:IO:Socket # Socket Interface (Ethernet or WiFi) - component: SDS:IO:VCOM&MDK USB # USB Interface - component: SDS:IO:Serial&CMSIS USART # USART Interface - component: SDS:IO:File System&MDK FS # Memory card - component: SDS:IO:File System&Semihosting # Simulation or Debugger To simplify usage further, the following pre-configured SDS interface layers in csolution project format are available. These connect via various interfaces to the SDSIO server that for read/write access to SDS data files. Ethernet Interface using the MDK-Middleware Network components. USB Interface using the MDK-Middleware USB components. The SDS interface layers can be further tailored for the application requirements. For example by removing the playback interface component when only recording is required. component: SDS:Player&CMSIS-RTOS2 # remove this when not required Layer: Network/SDS_Interface The Network/SDS_Interface.clayer is configured for recording and playback via Ethernet interface. It is using the MDK-Middleware Network component. Layer: USB/SDS_Interface The USB/SDS_Interface.clayer is configured for recording and playback via Ethernet interface. It is using the MDK-Middleware Network component.","title":"SDS Interface"},{"location":"sds_interface/#sds-interface","text":"The SDSIO components offer flexible recorder and playback interfaces. You may choose between these interface components that can be easily integrated into the target system: - component: SDS:IO:Socket # Socket Interface (Ethernet or WiFi) - component: SDS:IO:VCOM&MDK USB # USB Interface - component: SDS:IO:Serial&CMSIS USART # USART Interface - component: SDS:IO:File System&MDK FS # Memory card - component: SDS:IO:File System&Semihosting # Simulation or Debugger To simplify usage further, the following pre-configured SDS interface layers in csolution project format are available. These connect via various interfaces to the SDSIO server that for read/write access to SDS data files. Ethernet Interface using the MDK-Middleware Network components. USB Interface using the MDK-Middleware USB components. The SDS interface layers can be further tailored for the application requirements. For example by removing the playback interface component when only recording is required. component: SDS:Player&CMSIS-RTOS2 # remove this when not required","title":"SDS Interface"},{"location":"sds_interface/#layer-networksds_interface","text":"The Network/SDS_Interface.clayer is configured for recording and playback via Ethernet interface. It is using the MDK-Middleware Network component.","title":"Layer: Network/SDS_Interface"},{"location":"sds_interface/#layer-usbsds_interface","text":"The USB/SDS_Interface.clayer is configured for recording and playback via Ethernet interface. It is using the MDK-Middleware Network component.","title":"Layer: USB/SDS_Interface"},{"location":"theory/","text":"Theory of Operation The SDS Framework enables to record and playback one or more data streams to an application that is under development as shown in the diagram below. With the SDSIO Interface the data streams are connected to SDS data files. The file storage can be either embedded within the system and access by a file system or external on a host computer and accessed by a communication interface such as Ethernet or USB. The DSP or ML algorithms that are tested operate on blocks and are executed periodically. This documentation uses these terms: Block size : is the number of bytes processed by a DSP or ML compute node. Interval : is the periodic time interval that the compute node executes. The core of the SDS-Framework is a circular buffer handling ( sds.c/h ) that is controlled by the Recorder/Player interface functions ( sdsRec.c/h / sdsPlay.c/h ). This circular buffer is the queue for the file I/O communication ( sdsio.c/h ). Using the Recorder/Player functions, the data stream under development may read and write data streams as shown in the diagram above. Usage The following diagram shows the usage of the SDS Recorder and Player functions. Management is a separate thread that controls the overall execution. Algorithm is a thread that executes Signal Conditioning (SC) and ML Model. sequenceDiagram participant Management participant SDS Player participant SDS Recorder participant Algorithm Management->>SDS Player: sdsPlayOpen `SCinput` Management->>SDS Recorder: sdsRecOpen `SCoutput` Management->>SDS Recorder: sdsRecOpen `MLoutput` Management->>Algorithm: Activate Algorithm Activate Algorithm loop periodic SDS Player->>Algorithm: sdsPlayReads `SCinput` (with timestamp) Note over Algorithm: Execute Signal Conditioning Algorithm->>SDS Recorder: sdsRecWrite `SCoutput` Note over Algorithm: Execute ML Model Algorithm->>SDS Recorder: sdsRecWrite `MLoutput` end Management->>Algorithm: Deactivate Algorithm Deactivate Algorithm Management->>SDS Player: sdsPlayClose `SCinput` Management->>SDS Recorder: sdsRecClose `SCoutput` Management->>SDS Recorder: sdsRecClose `MCoutput` Each data stream is stored in a separate SDS data file. In the diagram below SCinput.0.sds is the input to Signal Conditioning, SCoutput.0.sds is the output of Signal Conditioning, and MLoutput.0.sds is the output of the ML Model. Each execution of the algorithm is represented in a data block with a timestamp . The timestamp allows to correlate the blocks of different streams. In the above example, all blocks of one algorithm execution have the same timestamp value. ToDo When does sdsRecInit require an event handler? Example: Recording of an accelerometer data stream The following code snippets show the usage of the Recorder Interface . // *** variable definitions *** struct { // sensor data stream format uint16_t x; uint16_t y; uint16_t z; } accelerometer [30]; // number of samples in one data stream record sdsRecId_t *accel_id, // data stream id uint8_t accel_buf[1000]; // data stream buffer for circular buffer handling : // *** function calls *** sdsRecInit(NULL); // init SDS Recorder : // open data stream for recording accel_id = sdsRecOpen(\"Accel\", accel_buf, sizeof(accel_buf), 2*(sizeof(accelerometer)); : // write data in accelerometer buffer with timestamp from RTOS kernel. timestamp = osKernelGetTickCount(); n = sdsRecWrite(accel_id, timestamp, accelerometer, sizeof(accelerometer)); if (n != sizeof(accelerometer)) { ... // unexpected size returned, error handling } : sdsRecClose (accel_id); // close data stream Buffer Size The size of the data stream buffer depends on several factors such as: the communication interface used as the technology may impose certain buffer sizes to maximize the transfer rate. the size of the data stream as it is recommended that the buffer is at least three the size of a single data stream. the frequency of the algorithm execution. Fast execution speeds may require a larger buffer. A a guideline, the buffer size should be 3 times the block size . As a minimum 0x1000 (4 KB) is recommended. ToDo: Threshold should be optional Recommended Buffer Size: The table below contains recommended buffer sizes depending on the communication technology used: ToDo Communication Buffer Size Description Network 4096 Default size of Ethernet record is xxxx bytes USB Device xxx . FileSystem xxx . Timestamp The timestamp is a 32-bit unsigned value and is used for: Alignment of different data streams that have the same timestamp value. Order of the SDS data files captured during execution. Combining multiple SDS file records with the same timestamp value. The same timestamp connects different SDS file records. It is therefore useful to use the same timestamp for the recording of one iteration of a DSP or ML algorithm. In most cases the granularity of an RTOS tick (typically 1ms) is a good choice for a timestamp value. SDS File Format The SDS file format is described here . Each call to sdsRecWrite creates one record. SDSIO Server Protocol The SDSIO Server uses a simple protocol for data exchange between a Host computer and the embedded target that integrates an SDSIO Interface . The protocol assumes that the correct communication to the server is already ensured by the underlying technology (TCP/IP or USB) and therefore no extra check is implemented. The following conventions describe the command semantic used in the following documentation\" Symbol Description > Prefix indicating the direction: Command from target to Host. < Prefix indicating the direction: Response from Host to target. WORD 32-bit value (low byte first). **** The field above has exactly one occurrence. ++++ The field above has a variable length. Commands: Commands are send from the embedded target to the Host computer that is running the SDSIO Server. ID Name Description 1 SDSIO_CMD_OPEN Open a SDS data file 2 SDSIO_CMD_CLOSE Close a SDS data file 3 SDSIO_CMD_WRITE Write to SDS data file 4 SDSIO_CMD_READ Read from SDS data file 5 SDSIO_CMD_EOS End of Stream Each Command starts with a Header (4 Words) and optional data with variable length. Depending on the Command, the SDSIO Server replies with a Response that repeats the Header and delivers additional data. SDSIO_CMD_OPEN The Command ID=1 SDSIO_CMD_OPEN opens an SDS data file on the Host computer. SDS data filenames use the following file format: <name>.<file-index>.sds . Name is the base file name of the SDS data file. Len of Name is the size of the string in bytes. <file-index> is a sequential number starting from 0 . Mode defines read (value=0) or write (value=1) operation. For write , the server inserts the next available <file-index> number that does not exist yet (if Name.3.sds exists, the server creates Name.4.sds ). For read the server maintains a list of Names that where previously used. When a Name was not used before it opens <file-index>=0 , i.e. Name.0.sds . | WORD | WORD **| WORD | WORD *******|++++++| > 1 | 0 | Mode | Len of Name | Name | |******|********|******|*************|++++++| The Response ID=1 SDSIO_CMD_OPEN provides a Handle that is used to identify the file in subsequent commands. | WORD | WORD **| WORD | WORD *******| < 1 | Handle | Mode | 0 | |******|********|******|*************| SDSIO_CMD_CLOSE The Command ID=2 SDSIO_CMD_CLOSE closes an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD | > 2 | Handle | 0 | 0 | |******|********|******|******| SDSIO_CMD_WRITE The Command ID=3 SDSIO_CMD_WRITE writes data to an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size is the Data size in bytes. There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD |++++++| > 3 | Handle | 0 | Size | Data | |******|********|******|******|++++++| SDSIO_CMD_READ The Command ID=4 SDSIO_CMD_READ reads data from an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size are the number of bytes that should be read. | WORD | WORD | WORD | WORD | > 4 | Handle | Size | 0 | |******|********|******|******| The Response ID=4 SDSIO_CMD_READ provides the data read from an SDS data file on the HOST computer. Size is the Data size in bytes that is read. | WORD | WORD | WORD | WORD |++++++| < 4 | Handle | 0 | Size | Data | |******|********|******|******|++++++| SDSIO_CMD_EOS The Command ID=5 SDSIO_CMD_EOS checks if the end of file is reached. The Handle is the identifier obtained with SDSIO_CMD_OPEN . | WORD | WORD | WORD | WORD | > 5 | Handle | 0 | 0 | |******|********|******|******| The Response ID=5 SDSIO_CMD_EOS returs the Status with nonzero = end of stream, else 0 | WORD | WORD | WORD | WORD | < 5 | Handle | Status | 0 | |******|********|********|******| ToDo: I don't understand why this command is needed as SDSIO_CMD_READ returns indirectly this status already. Also the nonzero above needs work. SDSIO Message Sequence This is the message sequence of the SDS DataTest example when connected to MDK-Middleware Ethernet. It contains the following threads that executes on the target. Management: Overall execution management Algorithm: Algorithm under test Recorder: SDS Recorder thread (sdsRecThread) Playback: SDS Playback thread (sdsPlayThread) The Server is the SDSIO Server executing on the target system. sequenceDiagram participant Management participant Algorithm create participant Recorder as SDS Recorder participant Server as SDSIO Server Management->>Recorder: sdsRecInit Note over Management: sdsRecOpen Management->>Server: SDSIO_CMD_OPEN activate Server Server-->>Management: Response activate Algorithm loop periodic Note over Algorithm: sdsRecWrite Algorithm->>Recorder: Threshold Trigger loop send all data Recorder->>Server: SDSIO_CMD_WRITE end end deactivate Algorithm Note over Management: sdsRecClose Management->>Recorder: Close Trigger loop send all data Recorder->>Server: SDSIO_CMD_WRITE end Recorder->>Management: Close Confirm Management->>Server: SDSIO_CMD_CLOSE deactivate Server ToDo: create similar diagram for Playback should Playback and Record use the same Thread? How is the buffer filled on PlayOpen? document control blocks in sds.c, sds_rec.c, and sds_play.c (comments might be sufficient) How does Threshold work? when Threshold is reach, the write operation writes the whole buffer. The transport layer (TCP/IP) may need to split this into multiple packs. Should size be optimized for transport layer? This writes all buffers https://github.com/ARM-software/SDS-Framework/blob/main/sds/source/sds_rec.c#L157 until empty. When Recorder is same priority as Algorithm, Algorithm might not be executed for quite a while. sds.c generates detailed events (are they documented?) but sds_rec.c does not really use this information Threshold event is only set when complete write was possible, is this correct? https://github.com/ARM-software/SDS-Framework/blob/main/sds/source/sds_rec.c#L298 https://github.com/Arm-Examples/SDS-Examples/blob/main/Hardware/DataTest/rec_management.c - do we really need recdone ?","title":"Theory of Operation"},{"location":"theory/#theory-of-operation","text":"The SDS Framework enables to record and playback one or more data streams to an application that is under development as shown in the diagram below. With the SDSIO Interface the data streams are connected to SDS data files. The file storage can be either embedded within the system and access by a file system or external on a host computer and accessed by a communication interface such as Ethernet or USB. The DSP or ML algorithms that are tested operate on blocks and are executed periodically. This documentation uses these terms: Block size : is the number of bytes processed by a DSP or ML compute node. Interval : is the periodic time interval that the compute node executes. The core of the SDS-Framework is a circular buffer handling ( sds.c/h ) that is controlled by the Recorder/Player interface functions ( sdsRec.c/h / sdsPlay.c/h ). This circular buffer is the queue for the file I/O communication ( sdsio.c/h ). Using the Recorder/Player functions, the data stream under development may read and write data streams as shown in the diagram above.","title":"Theory of Operation"},{"location":"theory/#usage","text":"The following diagram shows the usage of the SDS Recorder and Player functions. Management is a separate thread that controls the overall execution. Algorithm is a thread that executes Signal Conditioning (SC) and ML Model. sequenceDiagram participant Management participant SDS Player participant SDS Recorder participant Algorithm Management->>SDS Player: sdsPlayOpen `SCinput` Management->>SDS Recorder: sdsRecOpen `SCoutput` Management->>SDS Recorder: sdsRecOpen `MLoutput` Management->>Algorithm: Activate Algorithm Activate Algorithm loop periodic SDS Player->>Algorithm: sdsPlayReads `SCinput` (with timestamp) Note over Algorithm: Execute Signal Conditioning Algorithm->>SDS Recorder: sdsRecWrite `SCoutput` Note over Algorithm: Execute ML Model Algorithm->>SDS Recorder: sdsRecWrite `MLoutput` end Management->>Algorithm: Deactivate Algorithm Deactivate Algorithm Management->>SDS Player: sdsPlayClose `SCinput` Management->>SDS Recorder: sdsRecClose `SCoutput` Management->>SDS Recorder: sdsRecClose `MCoutput` Each data stream is stored in a separate SDS data file. In the diagram below SCinput.0.sds is the input to Signal Conditioning, SCoutput.0.sds is the output of Signal Conditioning, and MLoutput.0.sds is the output of the ML Model. Each execution of the algorithm is represented in a data block with a timestamp . The timestamp allows to correlate the blocks of different streams. In the above example, all blocks of one algorithm execution have the same timestamp value. ToDo When does sdsRecInit require an event handler? Example: Recording of an accelerometer data stream The following code snippets show the usage of the Recorder Interface . // *** variable definitions *** struct { // sensor data stream format uint16_t x; uint16_t y; uint16_t z; } accelerometer [30]; // number of samples in one data stream record sdsRecId_t *accel_id, // data stream id uint8_t accel_buf[1000]; // data stream buffer for circular buffer handling : // *** function calls *** sdsRecInit(NULL); // init SDS Recorder : // open data stream for recording accel_id = sdsRecOpen(\"Accel\", accel_buf, sizeof(accel_buf), 2*(sizeof(accelerometer)); : // write data in accelerometer buffer with timestamp from RTOS kernel. timestamp = osKernelGetTickCount(); n = sdsRecWrite(accel_id, timestamp, accelerometer, sizeof(accelerometer)); if (n != sizeof(accelerometer)) { ... // unexpected size returned, error handling } : sdsRecClose (accel_id); // close data stream","title":"Usage"},{"location":"theory/#buffer-size","text":"The size of the data stream buffer depends on several factors such as: the communication interface used as the technology may impose certain buffer sizes to maximize the transfer rate. the size of the data stream as it is recommended that the buffer is at least three the size of a single data stream. the frequency of the algorithm execution. Fast execution speeds may require a larger buffer. A a guideline, the buffer size should be 3 times the block size . As a minimum 0x1000 (4 KB) is recommended. ToDo: Threshold should be optional Recommended Buffer Size: The table below contains recommended buffer sizes depending on the communication technology used: ToDo Communication Buffer Size Description Network 4096 Default size of Ethernet record is xxxx bytes USB Device xxx . FileSystem xxx .","title":"Buffer Size"},{"location":"theory/#timestamp","text":"The timestamp is a 32-bit unsigned value and is used for: Alignment of different data streams that have the same timestamp value. Order of the SDS data files captured during execution. Combining multiple SDS file records with the same timestamp value. The same timestamp connects different SDS file records. It is therefore useful to use the same timestamp for the recording of one iteration of a DSP or ML algorithm. In most cases the granularity of an RTOS tick (typically 1ms) is a good choice for a timestamp value.","title":"Timestamp"},{"location":"theory/#sds-file-format","text":"The SDS file format is described here . Each call to sdsRecWrite creates one record.","title":"SDS File Format"},{"location":"theory/#sdsio-server-protocol","text":"The SDSIO Server uses a simple protocol for data exchange between a Host computer and the embedded target that integrates an SDSIO Interface . The protocol assumes that the correct communication to the server is already ensured by the underlying technology (TCP/IP or USB) and therefore no extra check is implemented. The following conventions describe the command semantic used in the following documentation\" Symbol Description > Prefix indicating the direction: Command from target to Host. < Prefix indicating the direction: Response from Host to target. WORD 32-bit value (low byte first). **** The field above has exactly one occurrence. ++++ The field above has a variable length. Commands: Commands are send from the embedded target to the Host computer that is running the SDSIO Server. ID Name Description 1 SDSIO_CMD_OPEN Open a SDS data file 2 SDSIO_CMD_CLOSE Close a SDS data file 3 SDSIO_CMD_WRITE Write to SDS data file 4 SDSIO_CMD_READ Read from SDS data file 5 SDSIO_CMD_EOS End of Stream Each Command starts with a Header (4 Words) and optional data with variable length. Depending on the Command, the SDSIO Server replies with a Response that repeats the Header and delivers additional data. SDSIO_CMD_OPEN The Command ID=1 SDSIO_CMD_OPEN opens an SDS data file on the Host computer. SDS data filenames use the following file format: <name>.<file-index>.sds . Name is the base file name of the SDS data file. Len of Name is the size of the string in bytes. <file-index> is a sequential number starting from 0 . Mode defines read (value=0) or write (value=1) operation. For write , the server inserts the next available <file-index> number that does not exist yet (if Name.3.sds exists, the server creates Name.4.sds ). For read the server maintains a list of Names that where previously used. When a Name was not used before it opens <file-index>=0 , i.e. Name.0.sds . | WORD | WORD **| WORD | WORD *******|++++++| > 1 | 0 | Mode | Len of Name | Name | |******|********|******|*************|++++++| The Response ID=1 SDSIO_CMD_OPEN provides a Handle that is used to identify the file in subsequent commands. | WORD | WORD **| WORD | WORD *******| < 1 | Handle | Mode | 0 | |******|********|******|*************| SDSIO_CMD_CLOSE The Command ID=2 SDSIO_CMD_CLOSE closes an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD | > 2 | Handle | 0 | 0 | |******|********|******|******| SDSIO_CMD_WRITE The Command ID=3 SDSIO_CMD_WRITE writes data to an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size is the Data size in bytes. There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD |++++++| > 3 | Handle | 0 | Size | Data | |******|********|******|******|++++++| SDSIO_CMD_READ The Command ID=4 SDSIO_CMD_READ reads data from an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size are the number of bytes that should be read. | WORD | WORD | WORD | WORD | > 4 | Handle | Size | 0 | |******|********|******|******| The Response ID=4 SDSIO_CMD_READ provides the data read from an SDS data file on the HOST computer. Size is the Data size in bytes that is read. | WORD | WORD | WORD | WORD |++++++| < 4 | Handle | 0 | Size | Data | |******|********|******|******|++++++| SDSIO_CMD_EOS The Command ID=5 SDSIO_CMD_EOS checks if the end of file is reached. The Handle is the identifier obtained with SDSIO_CMD_OPEN . | WORD | WORD | WORD | WORD | > 5 | Handle | 0 | 0 | |******|********|******|******| The Response ID=5 SDSIO_CMD_EOS returs the Status with nonzero = end of stream, else 0 | WORD | WORD | WORD | WORD | < 5 | Handle | Status | 0 | |******|********|********|******| ToDo: I don't understand why this command is needed as SDSIO_CMD_READ returns indirectly this status already. Also the nonzero above needs work.","title":"SDSIO Server Protocol"},{"location":"theory/#sdsio-message-sequence","text":"This is the message sequence of the SDS DataTest example when connected to MDK-Middleware Ethernet. It contains the following threads that executes on the target. Management: Overall execution management Algorithm: Algorithm under test Recorder: SDS Recorder thread (sdsRecThread) Playback: SDS Playback thread (sdsPlayThread) The Server is the SDSIO Server executing on the target system. sequenceDiagram participant Management participant Algorithm create participant Recorder as SDS Recorder participant Server as SDSIO Server Management->>Recorder: sdsRecInit Note over Management: sdsRecOpen Management->>Server: SDSIO_CMD_OPEN activate Server Server-->>Management: Response activate Algorithm loop periodic Note over Algorithm: sdsRecWrite Algorithm->>Recorder: Threshold Trigger loop send all data Recorder->>Server: SDSIO_CMD_WRITE end end deactivate Algorithm Note over Management: sdsRecClose Management->>Recorder: Close Trigger loop send all data Recorder->>Server: SDSIO_CMD_WRITE end Recorder->>Management: Close Confirm Management->>Server: SDSIO_CMD_CLOSE deactivate Server ToDo: create similar diagram for Playback should Playback and Record use the same Thread? How is the buffer filled on PlayOpen? document control blocks in sds.c, sds_rec.c, and sds_play.c (comments might be sufficient) How does Threshold work? when Threshold is reach, the write operation writes the whole buffer. The transport layer (TCP/IP) may need to split this into multiple packs. Should size be optimized for transport layer? This writes all buffers https://github.com/ARM-software/SDS-Framework/blob/main/sds/source/sds_rec.c#L157 until empty. When Recorder is same priority as Algorithm, Algorithm might not be executed for quite a while. sds.c generates detailed events (are they documented?) but sds_rec.c does not really use this information Threshold event is only set when complete write was possible, is this correct? https://github.com/ARM-software/SDS-Framework/blob/main/sds/source/sds_rec.c#L298 https://github.com/Arm-Examples/SDS-Examples/blob/main/Hardware/DataTest/rec_management.c - do we really need recdone ?","title":"SDSIO Message Sequence"},{"location":"utilities/","text":"Utilities The SDS-Framework includes the following utilities that are implemented in Python. SDSIO-Server: enables recording and playback of SDS data files via socket (TCP/IP) or serial (UART) connection. SDS-View: graphical data viewer for SDS data files. SDS-Convert: convert SDS data files into CSV, Qeexo V2 CSV, or WAV format. SDSIO-Server The Python utility SDSIO-Server enables recording and playback of SDS data files via socket (TCP/IP) or serial (UART) connection. It communicates with the target using these SDSIO interfaces : serial/usart for serial communication via CMSIS-Driver USART. socket for TCP/IP communication using MDK-Middleware, LwIP, or CMSIS-Driver WiFi. vcom/mdk for serial communication via USB VCom using MDK-Middleware. The SDS data stream is recorded to files with the following naming convention: <name>.<index>.sds <name> is the name of the I/O stream specified with the function sdsRecOpen or sdsPlayOpen on the target. <index> is the zero-based index which is incremented for each subsequent recording. The data content of the <name>.<index>.sds is described with metadata file <name>.sds.yml in YAML format . Usage Setup the Python-based sdsio-server.py tool as described in utilities/SDSIO-Server/README.md . Depending on the SDS interface used on the target use either Socket Mode or Serial Mode as described below. The SDSIO_Server terminates with Ctrl+C . Socket Mode usage: sdsio-server.py socket [-h] [--ipaddr <IP> | --interface <Interface>] [--port <TCP Port>] [--outdir <Output dir>] options: -h, --help show this help message and exit optional: --ipaddr <IP> Server IP address (not allowed with argument --interface) --interface <Interface> Network interface (not allowed with argument --ipaddr) --port <TCP Port> TCP port (default: 5050) --outdir <Output dir> Output directory Example: python sdsio-server.py socket --interface eth0 --outdir ./out_dir Serial Mode usage: sdsio-server.py serial [-h] -p <Serial Port> [--baudrate <Baudrate>] [--parity <Parity>] [--stopbits <Stop bits>] [--outdir <Output dir>] options: -h, --help show this help message and exit required: -p <Serial Port> Serial port optional: --baudrate <Baudrate> Baudrate (default: 115200) --parity <Parity> Parity: N = None, E = Even, O = Odd, M = Mark, S = Space (default: N) --stopbits <Stop bits> Stop bits: 1, 1.5, 2 (default: 1) --outdir <Output dir> Output directory Example: python sdsio-server.py serial -p COM0 --baudrate 115200 --outdir ./out_dir SDS-View The Python utility SDSIO-View outputs a time-based plot of SDS data files ( <name>.<index>.sds ) based on the meta-data file ( <name>.sds.yml . The horizontal time scale is derived from the number of data points in a recording and frequency provided in the metadata description. All plots form a single recording will be displayed on the same figure (shared vertical scale). If there are 3 values described in the metadata file, an optional 3D view may be displayed. Usage Setup the Python-based sds-view.py tool as described in utilities/SDS-View/README.md . Invoke the tool as explained below. usage: sds-view.py [-h] -y <yaml_file> -s <sds_file> [<sds_file> ...] [--3D] View SDS data options: -h, --help show this help message and exit required: -y <yaml_file> YAML sensor description file -s <sds_file> [<sds_file> ...] SDS data recording file optional: --3D Plot 3D view in addition to normal 2D Example: python sds-view.py -y test/Gyroscope.sds.yml -s test/Gyroscope.0.sds SDS-Convert The Python utility SDSIO-Convert converts SDS data files to selected format based on description in metadata (YAML) files. Usage Setup the Python-based sds-convert.py tool as described in utilities/SDS-Convert/README.md . Depending on the required format use the tool as shown below. Audio WAV usage: sds-convert.py audio_wav [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file Note The metadata and SDS data file pairs must be passed as arguments in the same order to decoded data correctly. Example: python sds-convert.py audio_wav -i Microphone.0.sds -o microphone.wav -y Microphone.sds.yml Simple CSV usage: sds-convert.py simple_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-tick <start-tick>] [--stop-tick <stop-tick>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-tick <start-tick> Exported data start tick (default: None) --stop-tick <stop-tick> Exported data stop tick (default: None) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decoded data correctly. Example: python sds-convert.py simple_csv -i Gyroscope.0.sds -o gyroscope_simple.csv -y Gyroscope.sds.yml --normalize --start-tick 0.2 --stop-tick 0.3 Qeexo V2 CSV usage: sds-convert.py qeexo_v2_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-tick <start-tick>] [--stop-tick <stop-tick>] [--label 'label'] [--interval <interval>] [--sds_index <sds_index>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-tick <start-tick> Exported data start tick (default: None) --stop-tick <stop-tick> Exported data stop tick (default: None) --label 'label' Qeexo class label for sensor data (default: None) --interval <interval> Qeexo timestamp interval in ms (default: 50) --sds_index <sds_index> SDS file index to write (default: <sensor>.0.sds) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decoded data correctly. Examples: Convert SDS data files to Qeexo V2 CSV files: python sds-convert.py qeexo_v2_csv -i Gyroscope.0.sds Accelerometer.0.sds -o sensor_fusion.csv -y Gyroscope.sds.yaml Accelerometer.sds.yaml --normalize --start-tick 200 --stop-tick 300 Convert Qeexo V2 CSV files to SDS data files: python sds-convert qeexo_v2_csv -i accelerometer_data.csv -o accelerometer.sds","title":"Utilities"},{"location":"utilities/#utilities","text":"The SDS-Framework includes the following utilities that are implemented in Python. SDSIO-Server: enables recording and playback of SDS data files via socket (TCP/IP) or serial (UART) connection. SDS-View: graphical data viewer for SDS data files. SDS-Convert: convert SDS data files into CSV, Qeexo V2 CSV, or WAV format.","title":"Utilities"},{"location":"utilities/#sdsio-server","text":"The Python utility SDSIO-Server enables recording and playback of SDS data files via socket (TCP/IP) or serial (UART) connection. It communicates with the target using these SDSIO interfaces : serial/usart for serial communication via CMSIS-Driver USART. socket for TCP/IP communication using MDK-Middleware, LwIP, or CMSIS-Driver WiFi. vcom/mdk for serial communication via USB VCom using MDK-Middleware. The SDS data stream is recorded to files with the following naming convention: <name>.<index>.sds <name> is the name of the I/O stream specified with the function sdsRecOpen or sdsPlayOpen on the target. <index> is the zero-based index which is incremented for each subsequent recording. The data content of the <name>.<index>.sds is described with metadata file <name>.sds.yml in YAML format .","title":"SDSIO-Server"},{"location":"utilities/#usage","text":"Setup the Python-based sdsio-server.py tool as described in utilities/SDSIO-Server/README.md . Depending on the SDS interface used on the target use either Socket Mode or Serial Mode as described below. The SDSIO_Server terminates with Ctrl+C .","title":"Usage"},{"location":"utilities/#socket-mode","text":"usage: sdsio-server.py socket [-h] [--ipaddr <IP> | --interface <Interface>] [--port <TCP Port>] [--outdir <Output dir>] options: -h, --help show this help message and exit optional: --ipaddr <IP> Server IP address (not allowed with argument --interface) --interface <Interface> Network interface (not allowed with argument --ipaddr) --port <TCP Port> TCP port (default: 5050) --outdir <Output dir> Output directory Example: python sdsio-server.py socket --interface eth0 --outdir ./out_dir","title":"Socket Mode"},{"location":"utilities/#serial-mode","text":"usage: sdsio-server.py serial [-h] -p <Serial Port> [--baudrate <Baudrate>] [--parity <Parity>] [--stopbits <Stop bits>] [--outdir <Output dir>] options: -h, --help show this help message and exit required: -p <Serial Port> Serial port optional: --baudrate <Baudrate> Baudrate (default: 115200) --parity <Parity> Parity: N = None, E = Even, O = Odd, M = Mark, S = Space (default: N) --stopbits <Stop bits> Stop bits: 1, 1.5, 2 (default: 1) --outdir <Output dir> Output directory Example: python sdsio-server.py serial -p COM0 --baudrate 115200 --outdir ./out_dir","title":"Serial Mode"},{"location":"utilities/#sds-view","text":"The Python utility SDSIO-View outputs a time-based plot of SDS data files ( <name>.<index>.sds ) based on the meta-data file ( <name>.sds.yml . The horizontal time scale is derived from the number of data points in a recording and frequency provided in the metadata description. All plots form a single recording will be displayed on the same figure (shared vertical scale). If there are 3 values described in the metadata file, an optional 3D view may be displayed.","title":"SDS-View"},{"location":"utilities/#usage_1","text":"Setup the Python-based sds-view.py tool as described in utilities/SDS-View/README.md . Invoke the tool as explained below. usage: sds-view.py [-h] -y <yaml_file> -s <sds_file> [<sds_file> ...] [--3D] View SDS data options: -h, --help show this help message and exit required: -y <yaml_file> YAML sensor description file -s <sds_file> [<sds_file> ...] SDS data recording file optional: --3D Plot 3D view in addition to normal 2D Example: python sds-view.py -y test/Gyroscope.sds.yml -s test/Gyroscope.0.sds","title":"Usage"},{"location":"utilities/#sds-convert","text":"The Python utility SDSIO-Convert converts SDS data files to selected format based on description in metadata (YAML) files.","title":"SDS-Convert"},{"location":"utilities/#usage_2","text":"Setup the Python-based sds-convert.py tool as described in utilities/SDS-Convert/README.md . Depending on the required format use the tool as shown below.","title":"Usage"},{"location":"utilities/#audio-wav","text":"usage: sds-convert.py audio_wav [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file Note The metadata and SDS data file pairs must be passed as arguments in the same order to decoded data correctly. Example: python sds-convert.py audio_wav -i Microphone.0.sds -o microphone.wav -y Microphone.sds.yml","title":"Audio WAV"},{"location":"utilities/#simple-csv","text":"usage: sds-convert.py simple_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-tick <start-tick>] [--stop-tick <stop-tick>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-tick <start-tick> Exported data start tick (default: None) --stop-tick <stop-tick> Exported data stop tick (default: None) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decoded data correctly. Example: python sds-convert.py simple_csv -i Gyroscope.0.sds -o gyroscope_simple.csv -y Gyroscope.sds.yml --normalize --start-tick 0.2 --stop-tick 0.3","title":"Simple CSV"},{"location":"utilities/#qeexo-v2-csv","text":"usage: sds-convert.py qeexo_v2_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-tick <start-tick>] [--stop-tick <stop-tick>] [--label 'label'] [--interval <interval>] [--sds_index <sds_index>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-tick <start-tick> Exported data start tick (default: None) --stop-tick <stop-tick> Exported data stop tick (default: None) --label 'label' Qeexo class label for sensor data (default: None) --interval <interval> Qeexo timestamp interval in ms (default: 50) --sds_index <sds_index> SDS file index to write (default: <sensor>.0.sds) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decoded data correctly. Examples: Convert SDS data files to Qeexo V2 CSV files: python sds-convert.py qeexo_v2_csv -i Gyroscope.0.sds Accelerometer.0.sds -o sensor_fusion.csv -y Gyroscope.sds.yaml Accelerometer.sds.yaml --normalize --start-tick 200 --stop-tick 300 Convert Qeexo V2 CSV files to SDS data files: python sds-convert qeexo_v2_csv -i accelerometer_data.csv -o accelerometer.sds","title":"Qeexo V2 CSV"}]}