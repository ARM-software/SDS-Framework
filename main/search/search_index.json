{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"SDS-Framework This documentation explains the usage of the SDS-Framework for developing DSP, ML, or Edge AI algorithms. Target Audience This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs. Manual Chapters Overview explains the features of the SDS-Framework and outlines the possibilities. SDS Template Application explains the usage of the SDS-Framework for algorithm testing. SDSIO Interface describes the various I/O interfaces (USB, Socket, File System) for connecting to the target. Utilities explains Python based utilities that operate with SDS data files for converting, viewing, recording, and playback. Theory of Operation explains data stream recording and playback. API Modules describes the C interface of the SDS functions that may be used in the target system. Revision History Version Description 2.0.0 Major updated release of the SDS-Framework 1.1.0 Minor updated version of the SDS-Framework 1.0.0 Initial release of the SDS-Framework","title":"Home"},{"location":"index.html#sds-framework","text":"This documentation explains the usage of the SDS-Framework for developing DSP, ML, or Edge AI algorithms.","title":"SDS-Framework"},{"location":"index.html#target-audience","text":"This user's guide assumes basic knowledge about Cortex-M software development. It is written for embedded software developers that work with C/C++ compiler toolchains and utilize microcontroller devices with Cortex-M processors and Ethos-U NPUs.","title":"Target Audience"},{"location":"index.html#manual-chapters","text":"Overview explains the features of the SDS-Framework and outlines the possibilities. SDS Template Application explains the usage of the SDS-Framework for algorithm testing. SDSIO Interface describes the various I/O interfaces (USB, Socket, File System) for connecting to the target. Utilities explains Python based utilities that operate with SDS data files for converting, viewing, recording, and playback. Theory of Operation explains data stream recording and playback. API Modules describes the C interface of the SDS functions that may be used in the target system.","title":"Manual Chapters"},{"location":"index.html#revision-history","text":"Version Description 2.0.0 Major updated release of the SDS-Framework 1.1.0 Minor updated version of the SDS-Framework 1.0.0 Initial release of the SDS-Framework","title":"Revision History"},{"location":"overview.html","text":"Overview The Synchronous Data Stream (SDS) Framework implements a data stream management, provides methods and utilities for developing and optimizing embedded applications that use DSP, ML, or Edge AI algorithms. The SDS-Framework allows you to capture simultaneously multiple data streams from different sources (sensors, audio, and video inputs) or the results of algorithms in real-time directly in target hardware. These data streams are stored in files. The captured data streams are useful in various steps of the development cycle, for example to: Validate physical input signals from sensors or output of algorithms. Provide input data to Digital Signal Processing (DSP) development tools such as filter designers. Provide input data to ML/AI development systems for model classification, training, and performance optimization. Provide input data for simulation using Arm Virtual Hardware (AVH-FVP) models for testing and validation. Data Capturing and Playback The following diagram shows the data capturing in a microcontroller system using a network communication and the playback in simulation using Arm Virtual Hardware - Fixed Virtual Platform . The SDS Recorder or Playback Interface is integrated into the target application and runs on the microcontroller. It enables data streaming into SDS data files via various interfaces such as Ethernet, UART, USB, or File System. The I/O implementation included in SDS utilizes the MDK-Middleware , however custom interfaces to other middleware or different communication channels can also be used. The SDSIO Server running on a host computer captures the recorded data stream and stores it in SDS data files. Each recording creates one set of SDS data files that are indicated by a sequential number. The SDS data files are in binary format and may be described using a YAML metadata file . With this information, other tools can utilize the content of the SDS data files as shown in the picture below. In a simulation environment, the SDS Playback Interface streams the SDS data files back to the algorithm under test. With this interface, the algorithm receives the same data stream as in the physical hardware. The setup can therefore be used for validation, performance optimizations, and runs even in CI environments for test automation.","title":"Overview"},{"location":"overview.html#overview","text":"The Synchronous Data Stream (SDS) Framework implements a data stream management, provides methods and utilities for developing and optimizing embedded applications that use DSP, ML, or Edge AI algorithms. The SDS-Framework allows you to capture simultaneously multiple data streams from different sources (sensors, audio, and video inputs) or the results of algorithms in real-time directly in target hardware. These data streams are stored in files. The captured data streams are useful in various steps of the development cycle, for example to: Validate physical input signals from sensors or output of algorithms. Provide input data to Digital Signal Processing (DSP) development tools such as filter designers. Provide input data to ML/AI development systems for model classification, training, and performance optimization. Provide input data for simulation using Arm Virtual Hardware (AVH-FVP) models for testing and validation.","title":"Overview"},{"location":"overview.html#data-capturing-and-playback","text":"The following diagram shows the data capturing in a microcontroller system using a network communication and the playback in simulation using Arm Virtual Hardware - Fixed Virtual Platform . The SDS Recorder or Playback Interface is integrated into the target application and runs on the microcontroller. It enables data streaming into SDS data files via various interfaces such as Ethernet, UART, USB, or File System. The I/O implementation included in SDS utilizes the MDK-Middleware , however custom interfaces to other middleware or different communication channels can also be used. The SDSIO Server running on a host computer captures the recorded data stream and stores it in SDS data files. Each recording creates one set of SDS data files that are indicated by a sequential number. The SDS data files are in binary format and may be described using a YAML metadata file . With this information, other tools can utilize the content of the SDS data files as shown in the picture below. In a simulation environment, the SDS Playback Interface streams the SDS data files back to the algorithm under test. With this interface, the algorithm receives the same data stream as in the physical hardware. The setup can therefore be used for validation, performance optimizations, and runs even in CI environments for test automation.","title":"Data Capturing and Playback"},{"location":"sdsio.html","text":"SDSIO Interface The SDSIO components offer flexible recorder and playback interfaces. You may choose between these interface components that are stored in the folder ./sds/source/sdsio . These interfaces can be accessed as CMSIS software components for integration into the target system: - component: SDS:IO:Socket # Socket Interface (Ethernet or WiFi) - component: SDS:IO:USB&MDK USB # USB Interface - component: SDS:IO:Serial&CMSIS USART # USART Interface - component: SDS:IO:File System&MDK FS # Memory card - component: SDS:IO:File System&Semihosting # Simulation or Debugger via Semihosting interface - component: SDS:IO:VSI # VSI Simulation interface of an AVH FVP - component: SDS:IO:Custom # Source code template for custom implementation To simplify usage further, the following pre-configured SDS interface layers in csolution project format are available. These connect via various interfaces to the SDSIO Server, which provides read/write access to SDS data files. Ethernet Interface using the MDK-Middleware Network component. USB Bulk Interface using the MDK-Middleware USB component. Memory Card Interface using the MDK-Middleware File System component. Layer: sdsio_network The layer/network/sdsio_network.clayer.yml is configured for recording and playback via Ethernet interface. It uses the MDK-Middleware Network component. Layer: sdsio_usb The layer/usb/sdsio_usb.clayer.yml is configured for recording and playback via USB Device interface. It uses the MDK-Middleware USB Device component. Layer: sdsio_fs The layer/filesystem/sdsio_fs.clayer is configured for recording and playback to/from the Memory Card. It uses the MDK-Middleware File System component. Layer: sdsio_fvp The layer/fvp/sdsio_fvp.clayer is configured for recording and playback to/from the Host computer. It uses the VSI interface , which is integrated into the simulation model.","title":"SDSIO Interface"},{"location":"sdsio.html#sdsio-interface","text":"The SDSIO components offer flexible recorder and playback interfaces. You may choose between these interface components that are stored in the folder ./sds/source/sdsio . These interfaces can be accessed as CMSIS software components for integration into the target system: - component: SDS:IO:Socket # Socket Interface (Ethernet or WiFi) - component: SDS:IO:USB&MDK USB # USB Interface - component: SDS:IO:Serial&CMSIS USART # USART Interface - component: SDS:IO:File System&MDK FS # Memory card - component: SDS:IO:File System&Semihosting # Simulation or Debugger via Semihosting interface - component: SDS:IO:VSI # VSI Simulation interface of an AVH FVP - component: SDS:IO:Custom # Source code template for custom implementation To simplify usage further, the following pre-configured SDS interface layers in csolution project format are available. These connect via various interfaces to the SDSIO Server, which provides read/write access to SDS data files. Ethernet Interface using the MDK-Middleware Network component. USB Bulk Interface using the MDK-Middleware USB component. Memory Card Interface using the MDK-Middleware File System component.","title":"SDSIO Interface"},{"location":"sdsio.html#layer-sdsio_network","text":"The layer/network/sdsio_network.clayer.yml is configured for recording and playback via Ethernet interface. It uses the MDK-Middleware Network component.","title":"Layer: sdsio_network"},{"location":"sdsio.html#layer-sdsio_usb","text":"The layer/usb/sdsio_usb.clayer.yml is configured for recording and playback via USB Device interface. It uses the MDK-Middleware USB Device component.","title":"Layer: sdsio_usb"},{"location":"sdsio.html#layer-sdsio_fs","text":"The layer/filesystem/sdsio_fs.clayer is configured for recording and playback to/from the Memory Card. It uses the MDK-Middleware File System component.","title":"Layer: sdsio_fs"},{"location":"sdsio.html#layer-sdsio_fvp","text":"The layer/fvp/sdsio_fvp.clayer is configured for recording and playback to/from the Host computer. It uses the VSI interface , which is integrated into the simulation model.","title":"Layer: sdsio_fvp"},{"location":"template.html","text":"SDS Template Application The SDS template application is a test framework for DSP and ML algorithms. It allows recording and playback of real-world data streams using physical hardware or on simulation models using (Arm Virtual Hardware - FVP) to an user algorithm under test. The real-world data streams are captured in SDS data files. This enables multiple uses cases: Validate and Optimize Algorithms using playback. This allows to repeat test cases with the same data streams. The captured data streams can be labeled and used as training data set for AI Models in MLOps systems. The SDS template application is implemented as CMSIS-Toolbox Reference Application . It is hardware agnostic and requires a SDSIO-Layer and a Board-Layer with drivers for the specific target hardware. The SDSIO-Layer connects the SDS template application to a communication interface for SDS file I/O operations. The following SDSIO interfaces are pre-configured: Ethernet Interface using the MDK-Middleware Network component. USB Bulk Interface using the MDK-Middleware USB component. Memory Card Interface using the MDK-Middleware File System component. With a custom SDSIO interface alternative file I/O configurations are possible. SDS Template Structure The structure of the SDS template application is shown below. Two projects select between data communication test and user algorithm test. Two target-types allow to deploy the test application on hardware (evaluation board) or AVH FVP (simulation model). A standard board layer that is provided in several BSP provides the hardware interface. The SDSIO layer uses for communication the MDK-Middleware or on AVH FVP target a virtual simulation interface (VSI). The build-types DebugRec or ReleaseRec configure the template to record SDS data files. This allows recording of the input data stream and the algorithm data stream using physical input peripherals on hardware. The build-types DebugPlay or ReleasePlay configure the template to playback SDS data files. This allows playback of the input data stream while also recording the algorithm data stream. The test application can run on hardware (evaluation board) or AVH FVP (simulation model). As the input data stream can be repeated it allows to verify and optimize the algorithm while capturing the output data stream. Working with the SDS Template The SDS template application and SDSIO interface layers are part of the SDS pack . Several Board Support Packs (BSP) contain board layers that support the required API interfaces. Refer to the Overview page of the pack to check the Provided connection API Interface of the layers. The table below lists the required API interfaces that should be provided by the Board-Layer . Required API Interface Description SDSIO File System CMSIS_MCI CMSIS-Driver MCI interface to memory card. CMSIS_VIO, STDOUT, STDERR For user button and printf output. SDSIO Network CMSIS_ETH CMSIS-Driver Ethernet MAC/PHY interface. CMSIS_VIO, STDOUT, STDERR For user button and printf output. SDSIO USB Device CMSIS_USB_Device CMSIS-Driver USB Device interface. CMSIS_VIO, STDOUT, STDERR For user button and printf output. Note When such a board layer is not available, it is possible to create a compatible board layer . Using VS Code This section explains how to use SDS template application with the Arm CMSIS Solution for VS Code. This extension is for example part of Keil Studio . For the example below the STM32F746G-DISCO board is used that provides interfaces for all SDSIO communication interfaces. Install Required Packs To make the software components available, install the SDS pack and the pack for the select evaluation board, for example with: >cpackget add ARM::SDS >cpackget add Keil::STM32F746G-DISCO_BSP Create New Solution The SDS template application is selected in the Create a new solution dialog for boards with layers in the BSP. Once the csolution project is loaded the VS Code IDE presents you with a dialog that lets you select a compatible software layer and a compiler toolchain that is available on your computer. Note The Add Software Layer dialog only appears when the BSP contains a board layer with compatible API Interfaces (see next section). ST board layers are configured for the Arm Compiler (AC6) using STM32CubeMX. However, it is easy to reconfigure for different compilers. The steps are provided in the BSP overview. Build the Template Application The SDS template applications contains two targets (evaluation board, AVH FVP simulation model) and two projects: DataTest is a data communication test between target and SDSIO server or filesystem. AlgorithmTest allows to add the DSP or ML algorithm that should be tested. Use the command CMSIS:Manage Solution Settings to choose a one project that you want to explore. Start with the DataTest first that should work \"out-of-the box\" on target hardware. Once the configuration is selected, use the build command to generate the template application. Then download the application to the selected target. Compile for Custom Hardware The steps to add a custom hardware configuration are: Open the *.csolution.yml file and add a new target-type . target-types: - type: MyHardware device: STM32U535CBTx variables: - Board-Layer: $SolutionDir()$\\Board\\MyHardware\\Board.clayer.yml - SDSIO-Layer: $SolutionDir()$\\layer\\usb\\sdsio_usb.clayer.yml Add a board layer that implements the API interfaces described above. Note You may copy an existing board layer as starting point. But typically these board layers support a range of reference applications and contain driver API interfaces that may be removed. The step above allows also manual configuration without using the VS Code IDE. Using DataTest The DataTest project validates the communication channel. Record on Simulation Model Select the target AVH-SSE-300 with Project DataTest and Build Type DebugRec to record SDS data files. Build and Run the application. This run should generate the files: .... Use SDS-Check to verify correctness of recording with: ... Playback on Simulation Model Rename output file ... Change to Build Type DebugPlay (target AVH-SSE-300 with Project DataTest ). This run should generate the files: ... Compare the output files with .... Record on Hardware Target .... Playback on Hardware Target ... Configure Bandwidth for DataTest The DataTest project uses a fixed algorithm to verify the communication interface. With the file datatest/sds_algorithm_config.h it is possible to configure bandwidth and interval to match the requirements of the algorithm that should be tested. Using AlgorithmTest ToDo Add User Algorithm In the SDS template application these files require changes to interface with the DSP and ML algorithm that is tested: algorithm/sds_algorithm_config.h configures the block size of data streams. algorithm/sds_algorithm_user.c is the interface to the DSP/ML algorithm under test. algorithm/sds_data_in_user.c is the interface to the physical data source. Example Projects Configured variants of the SDS template application are provided in a separate GitHub repository github.com/Arm-Examples/sds-examples . These examples show the usage of the SDS-Framework with real-world devices and use cases. Using Example Projects ToDo","title":"SDS Template Application"},{"location":"template.html#sds-template-application","text":"The SDS template application is a test framework for DSP and ML algorithms. It allows recording and playback of real-world data streams using physical hardware or on simulation models using (Arm Virtual Hardware - FVP) to an user algorithm under test. The real-world data streams are captured in SDS data files. This enables multiple uses cases: Validate and Optimize Algorithms using playback. This allows to repeat test cases with the same data streams. The captured data streams can be labeled and used as training data set for AI Models in MLOps systems. The SDS template application is implemented as CMSIS-Toolbox Reference Application . It is hardware agnostic and requires a SDSIO-Layer and a Board-Layer with drivers for the specific target hardware. The SDSIO-Layer connects the SDS template application to a communication interface for SDS file I/O operations. The following SDSIO interfaces are pre-configured: Ethernet Interface using the MDK-Middleware Network component. USB Bulk Interface using the MDK-Middleware USB component. Memory Card Interface using the MDK-Middleware File System component. With a custom SDSIO interface alternative file I/O configurations are possible.","title":"SDS Template Application"},{"location":"template.html#sds-template-structure","text":"The structure of the SDS template application is shown below. Two projects select between data communication test and user algorithm test. Two target-types allow to deploy the test application on hardware (evaluation board) or AVH FVP (simulation model). A standard board layer that is provided in several BSP provides the hardware interface. The SDSIO layer uses for communication the MDK-Middleware or on AVH FVP target a virtual simulation interface (VSI). The build-types DebugRec or ReleaseRec configure the template to record SDS data files. This allows recording of the input data stream and the algorithm data stream using physical input peripherals on hardware. The build-types DebugPlay or ReleasePlay configure the template to playback SDS data files. This allows playback of the input data stream while also recording the algorithm data stream. The test application can run on hardware (evaluation board) or AVH FVP (simulation model). As the input data stream can be repeated it allows to verify and optimize the algorithm while capturing the output data stream.","title":"SDS Template Structure"},{"location":"template.html#working-with-the-sds-template","text":"The SDS template application and SDSIO interface layers are part of the SDS pack . Several Board Support Packs (BSP) contain board layers that support the required API interfaces. Refer to the Overview page of the pack to check the Provided connection API Interface of the layers. The table below lists the required API interfaces that should be provided by the Board-Layer . Required API Interface Description SDSIO File System CMSIS_MCI CMSIS-Driver MCI interface to memory card. CMSIS_VIO, STDOUT, STDERR For user button and printf output. SDSIO Network CMSIS_ETH CMSIS-Driver Ethernet MAC/PHY interface. CMSIS_VIO, STDOUT, STDERR For user button and printf output. SDSIO USB Device CMSIS_USB_Device CMSIS-Driver USB Device interface. CMSIS_VIO, STDOUT, STDERR For user button and printf output. Note When such a board layer is not available, it is possible to create a compatible board layer .","title":"Working with the SDS Template"},{"location":"template.html#using-vs-code","text":"This section explains how to use SDS template application with the Arm CMSIS Solution for VS Code. This extension is for example part of Keil Studio . For the example below the STM32F746G-DISCO board is used that provides interfaces for all SDSIO communication interfaces.","title":"Using VS Code"},{"location":"template.html#install-required-packs","text":"To make the software components available, install the SDS pack and the pack for the select evaluation board, for example with: >cpackget add ARM::SDS >cpackget add Keil::STM32F746G-DISCO_BSP","title":"Install Required Packs"},{"location":"template.html#create-new-solution","text":"The SDS template application is selected in the Create a new solution dialog for boards with layers in the BSP. Once the csolution project is loaded the VS Code IDE presents you with a dialog that lets you select a compatible software layer and a compiler toolchain that is available on your computer. Note The Add Software Layer dialog only appears when the BSP contains a board layer with compatible API Interfaces (see next section). ST board layers are configured for the Arm Compiler (AC6) using STM32CubeMX. However, it is easy to reconfigure for different compilers. The steps are provided in the BSP overview.","title":"Create New Solution"},{"location":"template.html#build-the-template-application","text":"The SDS template applications contains two targets (evaluation board, AVH FVP simulation model) and two projects: DataTest is a data communication test between target and SDSIO server or filesystem. AlgorithmTest allows to add the DSP or ML algorithm that should be tested. Use the command CMSIS:Manage Solution Settings to choose a one project that you want to explore. Start with the DataTest first that should work \"out-of-the box\" on target hardware. Once the configuration is selected, use the build command to generate the template application. Then download the application to the selected target.","title":"Build the Template Application"},{"location":"template.html#compile-for-custom-hardware","text":"The steps to add a custom hardware configuration are: Open the *.csolution.yml file and add a new target-type . target-types: - type: MyHardware device: STM32U535CBTx variables: - Board-Layer: $SolutionDir()$\\Board\\MyHardware\\Board.clayer.yml - SDSIO-Layer: $SolutionDir()$\\layer\\usb\\sdsio_usb.clayer.yml Add a board layer that implements the API interfaces described above. Note You may copy an existing board layer as starting point. But typically these board layers support a range of reference applications and contain driver API interfaces that may be removed. The step above allows also manual configuration without using the VS Code IDE.","title":"Compile for Custom Hardware"},{"location":"template.html#using-datatest","text":"The DataTest project validates the communication channel.","title":"Using DataTest"},{"location":"template.html#record-on-simulation-model","text":"Select the target AVH-SSE-300 with Project DataTest and Build Type DebugRec to record SDS data files. Build and Run the application. This run should generate the files: .... Use SDS-Check to verify correctness of recording with: ...","title":"Record on Simulation Model"},{"location":"template.html#playback-on-simulation-model","text":"Rename output file ... Change to Build Type DebugPlay (target AVH-SSE-300 with Project DataTest ). This run should generate the files: ... Compare the output files with ....","title":"Playback on Simulation Model"},{"location":"template.html#record-on-hardware-target","text":"....","title":"Record on Hardware Target"},{"location":"template.html#playback-on-hardware-target","text":"...","title":"Playback on Hardware Target"},{"location":"template.html#configure-bandwidth-for-datatest","text":"The DataTest project uses a fixed algorithm to verify the communication interface. With the file datatest/sds_algorithm_config.h it is possible to configure bandwidth and interval to match the requirements of the algorithm that should be tested.","title":"Configure Bandwidth for DataTest"},{"location":"template.html#using-algorithmtest","text":"ToDo","title":"Using AlgorithmTest"},{"location":"template.html#add-user-algorithm","text":"In the SDS template application these files require changes to interface with the DSP and ML algorithm that is tested: algorithm/sds_algorithm_config.h configures the block size of data streams. algorithm/sds_algorithm_user.c is the interface to the DSP/ML algorithm under test. algorithm/sds_data_in_user.c is the interface to the physical data source.","title":"Add User Algorithm"},{"location":"template.html#example-projects","text":"Configured variants of the SDS template application are provided in a separate GitHub repository github.com/Arm-Examples/sds-examples . These examples show the usage of the SDS-Framework with real-world devices and use cases.","title":"Example Projects"},{"location":"template.html#using-example-projects","text":"ToDo","title":"Using Example Projects"},{"location":"theory.html","text":"Theory of Operation The SDS Framework enables to record and playback one or more data streams to an application that is under development as shown in the diagram below. With the SDSIO Interface the data streams are connected to SDS data files. The file storage can be either embedded within the system and accessed by a file system or external on a host computer and accessed by a communication interface such as Ethernet or USB. The DSP or ML algorithms that are tested operate on blocks and are executed periodically. This documentation uses these terms: Data Block : is a set of input or output data which is processed in one step by a DSP or ML compute note. Block size : is the number of bytes of a data block. Interval : is the periodic time interval that the compute node executes. The core of the SDS-Framework is a circular buffer handling ( sds_buffer.c/h ) that is controlled by the Recorder/Player interface functions ( sds_rec_play.c/h ). This circular buffer is the queue for the file I/O communication ( sdsio_x.c / sdsio.h ). Using the Recorder/Player functions, the data stream under development may read and write data streams as shown in the diagram above. Usage The following diagram shows the usage of the SDS Recorder and Player functions (executed in sdsRecPlayThread ). The sdsControlThread controls the overall execution. AlgorithmThread is the thread that executes Signal Conditioning (SC) and ML Model. sequenceDiagram participant sdsControlThread participant sdsRecPlayThread participant AlgorithmThread Note over sdsControlThread: sdsRecPlayInit activate sdsRecPlayThread Note over sdsControlThread: Open data streams Note over sdsRecPlayThread: Read content for<br/>'play' data streams activate AlgorithmThread loop periodic Note over AlgorithmThread: GetInputData<br/>(physical input or sdsPlayRead) Note over AlgorithmThread: Execute algorithm Note over AlgorithmThread: sdsRecWrite data streams Note over sdsRecPlayThread: Read/write data streams. end sdsControlThread-->>AlgorithmThread: Stop Algorithm AlgorithmThread-->>sdsControlThread: Stopped Note over sdsControlThread: Close data streams Note over sdsRecPlayThread: Flush and close<br/> data streams SDS Data Files Each data stream is stored in a separate SDS data file. In the diagram below SCinput.0.sds is the input to Signal Conditioning, SCoutput.0.sds is the output of Signal Conditioning, and MLoutput.0.sds is the output of the ML Model. Each execution of the algorithm is represented in a data block with a timestamp . The timestamp allows to correlate the blocks of different streams. In the above example, all blocks of one algorithm execution have the same timestamp value. Each call to the function sdsRecWrite writes one data block. Each call to the function sdsPlayRead reads one data block. Filenames SDS data files use the naming format <name>.<file-index>.sds . <name> is the base name specified by the user, and <file-index> is a sequential number that starts at 0. Recording (sdsRecOpen): The sdsRecOpen function takes <name> as input. When connected to a file system (e.g., the SDSIO-Server ), it scans for existing files with names matching the pattern <name>.<file-index>.sds , starting at index 0. It uses the first available index that does not yet exist to create a new file for recording. Example: If files SensorX.0.sds through SensorX.10.sds exist, the next file created will be SensorX.11.sds . Playback (sdsPlayOpen): The sdsPlayOpen function also takes <name> as input and determines which file to play based on the contents of a corresponding index file, <name>.index.txt . The following procedure outlines how sdsPlayOpen determines the playback file: The function checks if <name>.index.txt exists and contains a valid number. If it exists and contains a valid index (e.g., 3), that number is used as the <file-index> . If the file does not exist or contains an invalid value, the index defaults to 0 . The file <name>.<file-index>.sds is then opened for playback. If the file exists, it is opened for playback. The index file <name>.index.txt is updated to <file-index> + 1 for the next call to sdsPlayOpen. If the file does not exist, playback fails and the index file is created or reset to 0. This mechanism enables automatic sequential playback, while still allowing the user to select the initial playback index by editing the index file. Example: If SensorX.index.txt contains the value 2, the sdsPlayOpen function will attempt to open the file SensorX.2.sds . If the file exists, it is played and the index file is updated to 3 for the next playback. If the file does not exist, playback fails and the index file is reset to 0. Timestamp The timestamp is a 32-bit unsigned value and is used for: Alignment of different data streams that have the same timestamp value. Order of the SDS data files captured during execution. Combining multiple SDS file records with the same timestamp value. The same timestamp connects different SDS file records. It is therefore useful to use the same timestamp for the recording of one iteration of a DSP or ML algorithm. In most cases the granularity of an RTOS tick (typically 1ms) is a good choice for a timestamp value. File Format The SDS Framework uses a binary data file format to store the individual data streams. It supports the recording and playback of multiple data streams that may have jitters. Therefore each stream contains timestamp information that allows to correlate the data streams as it is for example required in a sensor fusion application. The binary data format (stored in *.<n>.sds data files) has a record structure with a variable size. Each record has the following format: timestamp : record timestamp in tick-frequency (32-bit unsigned integer, little endian) data size : number of data bytes in the record (32-bit unsigned integer, little endian) binary data : SDS stream (little endian, no padding) as described with the *.sds.yml file. YAML Metadata Format The content of each data stream may be described in a YAML metadata file that is created by the user. The following section defines the YAML format of this metadata file. The file sds.schema.json is a schema description of the SDS Format Description. sds: Start of the SDS Format Description name: Name of the Synchronous Data Stream (SDS) description: Additional descriptive text (optional) frequency: Capture frequency of the SDS tick-frequency: Tick frequency of the timestamp value (optional); default: 1000 for 1 millisecond interval content: List of values captured (see below) content: List of values captured (in the order of the data file) - value: Name of the value type: Data type of the value offset: Offset of the value (optional); default: 0 scale: Scale factor of the value (optional); default: 1.0 unit: Physical unit of the value (optional); default: no units Example This example defines a data stream with the name \"sensorX\" that contains the values of a gyroscope, temperature sensor, and additional raw data (that are not further described). The binary data that are coming form these sensors are stored in data files with the following file format: <sensor-name>.<file-index>.sds . In this example the files names could be: sensorX.0.sds # capture 0 sensorX.1.sds # capture 1 The following sensorX.sds.yml provides the format description of the SDS sensorX binary data files and may be used by data conversion utilities and data viewers. sds: # describes a synchronous data stream name: sensorX # user defined name description: Gyroscope stream with 1KHz, plus additional user data frequency: 1000 content: - value: x # Value name is 'x' type: uint16_t # stored using a 16-bit unsigned int scale: 0.2 # value is scaled by 0.2 unit: dps # base unit of the value - value: y type: uint16_t scale: 0.2 unit: dps - value: z type: uint16_t unit: dps # scale 1.0 is default - value: temp type: float unit: degree Celsius - value: raw type: uint16_t # raw data, no scale or unit given - value: flag type: uint32_t:1 # a single bit stored in a 32-bit int Code Example The following code snippets show the usage of the Recorder Interface . In this case an accelerometer data stream is recorded. // *** variable definitions *** struct { // sensor data stream format uint16_t x; uint16_t y; uint16_t z; } accelerometer [30]; // number of samples in one data stream record sdsRecId_t *accel_id, // data stream id uint8_t accel_buf[(sizeof(accelerometer)*2)+0x800]; // data stream buffer for circular buffer handling : // *** function calls *** sdsRecPlayInit(NULL); // init SDS Recorder/Player : // open data stream for recording accel_id = sdsRecOpen(\"Accel\", accel_buf, sizeof(accel_buf), 2*(sizeof(accelerometer)); : // write data in accelerometer buffer with timestamp from RTOS kernel. timestamp = osKernelGetTickCount(); n = sdsRecWrite(accel_id, timestamp, accelerometer, sizeof(accelerometer)); if (n != sizeof(accelerometer)) { ... // unexpected size returned, error handling } : sdsRecClose (accel_id); // close data stream Buffer Size The size of the data stream buffer depends on several factors such as: the communication interface technology that may impose specific buffer size requirements to maximize data transfer rates. the frequency of the algorithm execution. Fast execution speeds may require a larger buffer. As a guideline, the buffer size should be at least (2 \u00d7 block size) + 2 KB . The minimum recommended buffer size is 0x1000 (4 KB) . SDSIO Server Protocol The SDSIO Server uses a simple protocol for data exchange between a Host computer and the embedded target that integrates an SDSIO Interface . The protocol assumes that the correct communication to the server is already ensured by the underlying technology (TCP/IP or USB) and therefore no extra check is implemented. The following conventions describe the command semantic used in the following documentation: Symbol Description > Prefix indicating the direction: Command from target to Host. < Prefix indicating the direction: Response from Host to target. WORD 32-bit value (low byte first). **** The field above has exactly one occurrence. ++++ The field above has a variable length. Commands: Commands are sent from the embedded target to the Host computer running the SDSIO Server. ID Name Description 1 SDSIO_CMD_OPEN Open an SDS data file 2 SDSIO_CMD_CLOSE Close an SDS data file 3 SDSIO_CMD_WRITE Write to an SDS data file 4 SDSIO_CMD_READ Read from an SDS data file 5 SDSIO_CMD_PING Ping Server Each Command starts with a Header (4 Words) and optional data with variable length. Depending on the Command, the SDSIO Server replies with a Response that repeats the Header and delivers additional data. SDSIO_CMD_OPEN The Command ID=1 SDSIO_CMD_OPEN opens an SDS data file on the Host computer. Mode defines read (value=0) or write (value=1) operation. Len of Name is the size of the string in bytes. SDS data filenames use the following file format: <name>.<file-index>.sds , where Name is the base file name of the SDS data file and <file-index> is a sequential number maintained by SDSIO Server (for details see section Filenames ). | WORD | WORD | WORD | WORD *******|++++++| > 1 | 0 | Mode | Len of Name | Name | |******|********|******|*************|++++++| The Response ID=1 SDSIO_CMD_OPEN provides a Handle that is used to identify the file in subsequent commands. | WORD | WORD | WORD | WORD *******| < 1 | Handle | Mode | 0 | |******|********|******|*************| SDSIO_CMD_CLOSE The Command ID=2 SDSIO_CMD_CLOSE closes an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD | > 2 | Handle | 0 | 0 | |******|********|******|******| SDSIO_CMD_WRITE The Command ID=3 SDSIO_CMD_WRITE writes data to an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size is the Data size in bytes. There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD |++++++| > 3 | Handle | 0 | Size | Data | |******|********|******|******|++++++| SDSIO_CMD_READ The Command ID=4 SDSIO_CMD_READ reads data from an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size are the number of bytes that should be read. | WORD | WORD | WORD | WORD | > 4 | Handle | Size | 0 | |******|********|******|******| The Response ID=4 SDSIO_CMD_READ provides the data read from an SDS data file on the HOST computer. Size is the Data size in bytes that was read and Status with nonzero = end of stream, else 0. | WORD | WORD | WORD | WORD |++++++| < 4 | Handle | Status | Size | Data | |******|********|********|******|++++++| SDSIO_CMD_PING The Command ID=5 SDSIO_CMD_PING verifies if the Server is active and reachable on the Host. | WORD | WORD | WORD | WORD | > 5 | 0 | 0 | 0 | |******|******|******|******| The Response ID=5 SDSIO_CMD_PING returns the Status with nonzero = server active, else 0 | WORD | WORD | WORD | WORD | < 5 | 0 | Status | 0 | |******|******|********|******| SDSIO Message Sequence This is the message sequence of the SDS DataTest example when connected to MDK-Middleware Ethernet. It contains the following threads that execute on the target. Control: Overall execution Control thread (sdsControlThread) Algorithm: Algorithm under test thread (AlgorithmThread) Recorder/Playback: SDS Recorder/Playback thread (sdsRecPlayThread) The Server is the SDSIO Server executing on the target system. Recording flowchart sequenceDiagram participant sdsControlThread activate sdsControlThread participant AlgorithmThread participant Recorder as sdsRecPlayThread participant Server as SDSIO Server activate Server Note over sdsControlThread: sdsRecPlayInit sdsControlThread->>Server: SDSIO_CMD_PING Server-->>sdsControlThread: Response sdsControlThread->>Recorder: Create thread activate Recorder Note over sdsControlThread: sdsRecOpen sdsControlThread->>Server: SDSIO_CMD_OPEN Server-->>sdsControlThread: Response activate AlgorithmThread loop periodic Note over AlgorithmThread: sdsRecWrite AlgorithmThread->>Recorder: Buffer data reached or crossed threshold loop send all data from buffer Recorder->>Server: SDSIO_CMD_WRITE end end deactivate AlgorithmThread Note over sdsControlThread: sdsRecClose sdsControlThread->>Recorder: Close request loop send all data from buffer Recorder->>Server: SDSIO_CMD_WRITE end Recorder->>sdsControlThread: Close confirm sdsControlThread->>Server: SDSIO_CMD_CLOSE Note over sdsControlThread: sdsRecPlayUninit sdsControlThread->>Recorder: Terminate thread deactivate Recorder deactivate Server deactivate sdsControlThread Playback flowchart sequenceDiagram participant sdsControlThread activate sdsControlThread participant AlgorithmThread participant Playback as sdsRecPlayThread participant Server as SDSIO Server activate Server Note over sdsControlThread: sdsRecPlayInit sdsControlThread->>Server: SDSIO_CMD_PING Server-->>sdsControlThread: Response sdsControlThread->>Playback: Create thread activate Playback Note over sdsControlThread: sdsPlayOpen sdsControlThread->>Server: SDSIO_CMD_OPEN Server-->>sdsControlThread: Response sdsControlThread->>Playback: Open request loop read data until threshold Playback->>Server: SDSIO_CMD_READ Server-->>Playback: Data end Playback->>sdsControlThread: Open confirm activate AlgorithmThread loop periodic Note over AlgorithmThread: sdsPlayRead AlgorithmThread->>Playback: Buffer data falls below threshold loop read data to fill the buffer Playback->>Server: SDSIO_CMD_READ Server-->>Playback: Data end end deactivate AlgorithmThread Note over sdsControlThread: sdsPlayClose sdsControlThread->>Server: SDSIO_CMD_CLOSE Note over sdsControlThread: sdsRecPlayUninit sdsControlThread->>Playback: Terminate thread deactivate Playback deactivate Server deactivate sdsControlThread","title":"Theory of Operation"},{"location":"theory.html#theory-of-operation","text":"The SDS Framework enables to record and playback one or more data streams to an application that is under development as shown in the diagram below. With the SDSIO Interface the data streams are connected to SDS data files. The file storage can be either embedded within the system and accessed by a file system or external on a host computer and accessed by a communication interface such as Ethernet or USB. The DSP or ML algorithms that are tested operate on blocks and are executed periodically. This documentation uses these terms: Data Block : is a set of input or output data which is processed in one step by a DSP or ML compute note. Block size : is the number of bytes of a data block. Interval : is the periodic time interval that the compute node executes. The core of the SDS-Framework is a circular buffer handling ( sds_buffer.c/h ) that is controlled by the Recorder/Player interface functions ( sds_rec_play.c/h ). This circular buffer is the queue for the file I/O communication ( sdsio_x.c / sdsio.h ). Using the Recorder/Player functions, the data stream under development may read and write data streams as shown in the diagram above.","title":"Theory of Operation"},{"location":"theory.html#usage","text":"The following diagram shows the usage of the SDS Recorder and Player functions (executed in sdsRecPlayThread ). The sdsControlThread controls the overall execution. AlgorithmThread is the thread that executes Signal Conditioning (SC) and ML Model. sequenceDiagram participant sdsControlThread participant sdsRecPlayThread participant AlgorithmThread Note over sdsControlThread: sdsRecPlayInit activate sdsRecPlayThread Note over sdsControlThread: Open data streams Note over sdsRecPlayThread: Read content for<br/>'play' data streams activate AlgorithmThread loop periodic Note over AlgorithmThread: GetInputData<br/>(physical input or sdsPlayRead) Note over AlgorithmThread: Execute algorithm Note over AlgorithmThread: sdsRecWrite data streams Note over sdsRecPlayThread: Read/write data streams. end sdsControlThread-->>AlgorithmThread: Stop Algorithm AlgorithmThread-->>sdsControlThread: Stopped Note over sdsControlThread: Close data streams Note over sdsRecPlayThread: Flush and close<br/> data streams","title":"Usage"},{"location":"theory.html#sds-data-files","text":"Each data stream is stored in a separate SDS data file. In the diagram below SCinput.0.sds is the input to Signal Conditioning, SCoutput.0.sds is the output of Signal Conditioning, and MLoutput.0.sds is the output of the ML Model. Each execution of the algorithm is represented in a data block with a timestamp . The timestamp allows to correlate the blocks of different streams. In the above example, all blocks of one algorithm execution have the same timestamp value. Each call to the function sdsRecWrite writes one data block. Each call to the function sdsPlayRead reads one data block.","title":"SDS Data Files"},{"location":"theory.html#filenames","text":"SDS data files use the naming format <name>.<file-index>.sds . <name> is the base name specified by the user, and <file-index> is a sequential number that starts at 0. Recording (sdsRecOpen): The sdsRecOpen function takes <name> as input. When connected to a file system (e.g., the SDSIO-Server ), it scans for existing files with names matching the pattern <name>.<file-index>.sds , starting at index 0. It uses the first available index that does not yet exist to create a new file for recording. Example: If files SensorX.0.sds through SensorX.10.sds exist, the next file created will be SensorX.11.sds . Playback (sdsPlayOpen): The sdsPlayOpen function also takes <name> as input and determines which file to play based on the contents of a corresponding index file, <name>.index.txt . The following procedure outlines how sdsPlayOpen determines the playback file: The function checks if <name>.index.txt exists and contains a valid number. If it exists and contains a valid index (e.g., 3), that number is used as the <file-index> . If the file does not exist or contains an invalid value, the index defaults to 0 . The file <name>.<file-index>.sds is then opened for playback. If the file exists, it is opened for playback. The index file <name>.index.txt is updated to <file-index> + 1 for the next call to sdsPlayOpen. If the file does not exist, playback fails and the index file is created or reset to 0. This mechanism enables automatic sequential playback, while still allowing the user to select the initial playback index by editing the index file. Example: If SensorX.index.txt contains the value 2, the sdsPlayOpen function will attempt to open the file SensorX.2.sds . If the file exists, it is played and the index file is updated to 3 for the next playback. If the file does not exist, playback fails and the index file is reset to 0.","title":"Filenames"},{"location":"theory.html#timestamp","text":"The timestamp is a 32-bit unsigned value and is used for: Alignment of different data streams that have the same timestamp value. Order of the SDS data files captured during execution. Combining multiple SDS file records with the same timestamp value. The same timestamp connects different SDS file records. It is therefore useful to use the same timestamp for the recording of one iteration of a DSP or ML algorithm. In most cases the granularity of an RTOS tick (typically 1ms) is a good choice for a timestamp value.","title":"Timestamp"},{"location":"theory.html#file-format","text":"The SDS Framework uses a binary data file format to store the individual data streams. It supports the recording and playback of multiple data streams that may have jitters. Therefore each stream contains timestamp information that allows to correlate the data streams as it is for example required in a sensor fusion application. The binary data format (stored in *.<n>.sds data files) has a record structure with a variable size. Each record has the following format: timestamp : record timestamp in tick-frequency (32-bit unsigned integer, little endian) data size : number of data bytes in the record (32-bit unsigned integer, little endian) binary data : SDS stream (little endian, no padding) as described with the *.sds.yml file.","title":"File Format"},{"location":"theory.html#yaml-metadata-format","text":"The content of each data stream may be described in a YAML metadata file that is created by the user. The following section defines the YAML format of this metadata file. The file sds.schema.json is a schema description of the SDS Format Description. sds: Start of the SDS Format Description name: Name of the Synchronous Data Stream (SDS) description: Additional descriptive text (optional) frequency: Capture frequency of the SDS tick-frequency: Tick frequency of the timestamp value (optional); default: 1000 for 1 millisecond interval content: List of values captured (see below) content: List of values captured (in the order of the data file) - value: Name of the value type: Data type of the value offset: Offset of the value (optional); default: 0 scale: Scale factor of the value (optional); default: 1.0 unit: Physical unit of the value (optional); default: no units Example This example defines a data stream with the name \"sensorX\" that contains the values of a gyroscope, temperature sensor, and additional raw data (that are not further described). The binary data that are coming form these sensors are stored in data files with the following file format: <sensor-name>.<file-index>.sds . In this example the files names could be: sensorX.0.sds # capture 0 sensorX.1.sds # capture 1 The following sensorX.sds.yml provides the format description of the SDS sensorX binary data files and may be used by data conversion utilities and data viewers. sds: # describes a synchronous data stream name: sensorX # user defined name description: Gyroscope stream with 1KHz, plus additional user data frequency: 1000 content: - value: x # Value name is 'x' type: uint16_t # stored using a 16-bit unsigned int scale: 0.2 # value is scaled by 0.2 unit: dps # base unit of the value - value: y type: uint16_t scale: 0.2 unit: dps - value: z type: uint16_t unit: dps # scale 1.0 is default - value: temp type: float unit: degree Celsius - value: raw type: uint16_t # raw data, no scale or unit given - value: flag type: uint32_t:1 # a single bit stored in a 32-bit int","title":"YAML Metadata Format"},{"location":"theory.html#code-example","text":"The following code snippets show the usage of the Recorder Interface . In this case an accelerometer data stream is recorded. // *** variable definitions *** struct { // sensor data stream format uint16_t x; uint16_t y; uint16_t z; } accelerometer [30]; // number of samples in one data stream record sdsRecId_t *accel_id, // data stream id uint8_t accel_buf[(sizeof(accelerometer)*2)+0x800]; // data stream buffer for circular buffer handling : // *** function calls *** sdsRecPlayInit(NULL); // init SDS Recorder/Player : // open data stream for recording accel_id = sdsRecOpen(\"Accel\", accel_buf, sizeof(accel_buf), 2*(sizeof(accelerometer)); : // write data in accelerometer buffer with timestamp from RTOS kernel. timestamp = osKernelGetTickCount(); n = sdsRecWrite(accel_id, timestamp, accelerometer, sizeof(accelerometer)); if (n != sizeof(accelerometer)) { ... // unexpected size returned, error handling } : sdsRecClose (accel_id); // close data stream","title":"Code Example"},{"location":"theory.html#buffer-size","text":"The size of the data stream buffer depends on several factors such as: the communication interface technology that may impose specific buffer size requirements to maximize data transfer rates. the frequency of the algorithm execution. Fast execution speeds may require a larger buffer. As a guideline, the buffer size should be at least (2 \u00d7 block size) + 2 KB . The minimum recommended buffer size is 0x1000 (4 KB) .","title":"Buffer Size"},{"location":"theory.html#sdsio-server-protocol","text":"The SDSIO Server uses a simple protocol for data exchange between a Host computer and the embedded target that integrates an SDSIO Interface . The protocol assumes that the correct communication to the server is already ensured by the underlying technology (TCP/IP or USB) and therefore no extra check is implemented. The following conventions describe the command semantic used in the following documentation: Symbol Description > Prefix indicating the direction: Command from target to Host. < Prefix indicating the direction: Response from Host to target. WORD 32-bit value (low byte first). **** The field above has exactly one occurrence. ++++ The field above has a variable length. Commands: Commands are sent from the embedded target to the Host computer running the SDSIO Server. ID Name Description 1 SDSIO_CMD_OPEN Open an SDS data file 2 SDSIO_CMD_CLOSE Close an SDS data file 3 SDSIO_CMD_WRITE Write to an SDS data file 4 SDSIO_CMD_READ Read from an SDS data file 5 SDSIO_CMD_PING Ping Server Each Command starts with a Header (4 Words) and optional data with variable length. Depending on the Command, the SDSIO Server replies with a Response that repeats the Header and delivers additional data. SDSIO_CMD_OPEN The Command ID=1 SDSIO_CMD_OPEN opens an SDS data file on the Host computer. Mode defines read (value=0) or write (value=1) operation. Len of Name is the size of the string in bytes. SDS data filenames use the following file format: <name>.<file-index>.sds , where Name is the base file name of the SDS data file and <file-index> is a sequential number maintained by SDSIO Server (for details see section Filenames ). | WORD | WORD | WORD | WORD *******|++++++| > 1 | 0 | Mode | Len of Name | Name | |******|********|******|*************|++++++| The Response ID=1 SDSIO_CMD_OPEN provides a Handle that is used to identify the file in subsequent commands. | WORD | WORD | WORD | WORD *******| < 1 | Handle | Mode | 0 | |******|********|******|*************| SDSIO_CMD_CLOSE The Command ID=2 SDSIO_CMD_CLOSE closes an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD | > 2 | Handle | 0 | 0 | |******|********|******|******| SDSIO_CMD_WRITE The Command ID=3 SDSIO_CMD_WRITE writes data to an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size is the Data size in bytes. There is no Response from the SDSIO Server on this command. | WORD | WORD | WORD | WORD |++++++| > 3 | Handle | 0 | Size | Data | |******|********|******|******|++++++| SDSIO_CMD_READ The Command ID=4 SDSIO_CMD_READ reads data from an SDS data file on the Host computer. The Handle is the identifier obtained with SDSIO_CMD_OPEN . Size are the number of bytes that should be read. | WORD | WORD | WORD | WORD | > 4 | Handle | Size | 0 | |******|********|******|******| The Response ID=4 SDSIO_CMD_READ provides the data read from an SDS data file on the HOST computer. Size is the Data size in bytes that was read and Status with nonzero = end of stream, else 0. | WORD | WORD | WORD | WORD |++++++| < 4 | Handle | Status | Size | Data | |******|********|********|******|++++++| SDSIO_CMD_PING The Command ID=5 SDSIO_CMD_PING verifies if the Server is active and reachable on the Host. | WORD | WORD | WORD | WORD | > 5 | 0 | 0 | 0 | |******|******|******|******| The Response ID=5 SDSIO_CMD_PING returns the Status with nonzero = server active, else 0 | WORD | WORD | WORD | WORD | < 5 | 0 | Status | 0 | |******|******|********|******|","title":"SDSIO Server Protocol"},{"location":"theory.html#sdsio-message-sequence","text":"This is the message sequence of the SDS DataTest example when connected to MDK-Middleware Ethernet. It contains the following threads that execute on the target. Control: Overall execution Control thread (sdsControlThread) Algorithm: Algorithm under test thread (AlgorithmThread) Recorder/Playback: SDS Recorder/Playback thread (sdsRecPlayThread) The Server is the SDSIO Server executing on the target system. Recording flowchart sequenceDiagram participant sdsControlThread activate sdsControlThread participant AlgorithmThread participant Recorder as sdsRecPlayThread participant Server as SDSIO Server activate Server Note over sdsControlThread: sdsRecPlayInit sdsControlThread->>Server: SDSIO_CMD_PING Server-->>sdsControlThread: Response sdsControlThread->>Recorder: Create thread activate Recorder Note over sdsControlThread: sdsRecOpen sdsControlThread->>Server: SDSIO_CMD_OPEN Server-->>sdsControlThread: Response activate AlgorithmThread loop periodic Note over AlgorithmThread: sdsRecWrite AlgorithmThread->>Recorder: Buffer data reached or crossed threshold loop send all data from buffer Recorder->>Server: SDSIO_CMD_WRITE end end deactivate AlgorithmThread Note over sdsControlThread: sdsRecClose sdsControlThread->>Recorder: Close request loop send all data from buffer Recorder->>Server: SDSIO_CMD_WRITE end Recorder->>sdsControlThread: Close confirm sdsControlThread->>Server: SDSIO_CMD_CLOSE Note over sdsControlThread: sdsRecPlayUninit sdsControlThread->>Recorder: Terminate thread deactivate Recorder deactivate Server deactivate sdsControlThread Playback flowchart sequenceDiagram participant sdsControlThread activate sdsControlThread participant AlgorithmThread participant Playback as sdsRecPlayThread participant Server as SDSIO Server activate Server Note over sdsControlThread: sdsRecPlayInit sdsControlThread->>Server: SDSIO_CMD_PING Server-->>sdsControlThread: Response sdsControlThread->>Playback: Create thread activate Playback Note over sdsControlThread: sdsPlayOpen sdsControlThread->>Server: SDSIO_CMD_OPEN Server-->>sdsControlThread: Response sdsControlThread->>Playback: Open request loop read data until threshold Playback->>Server: SDSIO_CMD_READ Server-->>Playback: Data end Playback->>sdsControlThread: Open confirm activate AlgorithmThread loop periodic Note over AlgorithmThread: sdsPlayRead AlgorithmThread->>Playback: Buffer data falls below threshold loop read data to fill the buffer Playback->>Server: SDSIO_CMD_READ Server-->>Playback: Data end end deactivate AlgorithmThread Note over sdsControlThread: sdsPlayClose sdsControlThread->>Server: SDSIO_CMD_CLOSE Note over sdsControlThread: sdsRecPlayUninit sdsControlThread->>Playback: Terminate thread deactivate Playback deactivate Server deactivate sdsControlThread","title":"SDSIO Message Sequence"},{"location":"utilities.html","text":"Utilities The SDS-Framework includes the following utilities that are implemented in Python. SDSIO-Server: enables recording and playback of SDS data files via socket (TCP/IP), USB (Bulk transfer) or serial (UART) connection. SDS-View: graphical data viewer for SDS data files. SDS-Convert: convert SDS data files into CSV, Qeexo V2 CSV, or WAV format. SDS-Check: check SDS data files for correctness and consistency. Requirements Python 3.9 or later with packages: ifaddr matplotlib numpy pandas pyyaml pyserial libusb1 Setup Verify the installed Python version with: python --version Option 1: Use a Python environment: python -m venv sds // create environment with name sds sds\\Scripts\\activate pip install -r requirements.txt Option 2: Install the required Python packages with pip : pip install ifaddr matplotlib numpy pandas pyyaml pyserial libusb1 SDSIO-Server The Python utility SDSIO-Server enables recording and playback of SDS data files via socket (TCP/IP), USB (Bulk transfer), or serial (UART) connection. It communicates with the target using these SDSIO Client interfaces : serial/usart for serial communication via CMSIS-Driver USART. socket for TCP/IP communication via IoT Socket using MDK-Middleware, LwIP, or CMSIS-Driver WiFi. usb/bulk for communication via USB Bulk transfer using MDK-Middleware. The SDS data stream is recorded to files with the following naming convention: <name>.<index>.sds <name> is the name of the I/O stream specified with the function sdsRecOpen or sdsPlayOpen on the target. <index> is the zero-based index which is incremented for each subsequent recording. For more details see Filenames section The data content of the <name>.<index>.sds is described with metadata file <name>.sds.yml in YAML format . Usage Setup the Python environment. Depending on the SDS interface used on the target use either Serial Mode , Socket Mode or USB Mode as described below. The SDSIO_Server terminates with Ctrl+C . Serial Mode usage: sdsio-server.py serial [-h] -p <Serial Port> [--baudrate <Baudrate>] [--parity <Parity>] [--stopbits <Stop bits>] [--connect-timeout <Timeout>] [--workdir <Work dir>] optional arguments: -h, --help show this help message and exit required: -p <Serial Port> Serial port optional: --baudrate <Baudrate> Baudrate (default: 115200) --parity <Parity> Parity: N=None, E=Even, O=Odd, M=Mark, S=Space (default: N) --stopbits <Stop bits> Stop bits: 1, 1.5, 2 (default: 1) --connect-timeout <Timeout> Serial port connection timeout in seconds (default: no timeout) --workdir <Work dir> Directory for SDS files (default: current directory) Example: python sdsio-server.py serial -p COM0 --baudrate 115200 --workdir ./work_dir Socket Mode usage: sdsio-server.py socket [-h] [--ipaddr <IP> | --interface <Interface>] [--port <TCP Port>] [--workdir <Work dir>] optional arguments: -h, --help show this help message and exit optional: --ipaddr <IP> Server IP address (cannot be used with --interface) --interface <Interface> Network interface (cannot be used with --ipaddr) --port <TCP Port> TCP port (default: 5050) --workdir <Work dir> Directory for SDS files (default: current directory) Note The --ipaddr and --interface options are mutually exclusive. SDSIO Server only supports IPv4 addresses. Example: For Microsoft Windows (using default computer IP): python sdsio-server.py socket --workdir ./work_dir For Linux: python sdsio-server.py socket --interface eth0 --workdir ./work_dir USB Mode usage: sdsio-server.py usb [-h] [--workdir <Work dir>] [--high-priority] optional arguments: -h, --help show this help message and exit optional: --workdir <Work dir> Directory for SDS files (default: current directory) --high-priority Enable high-priority threading for USB server (default: off) Note For more reliable operation at higher data transfer rates, it is recommended to enable the --high-priority option. This increases the thread priority of the SDSIO-Server process. When using --high-priority , elevated privileges are required depending on your operating system: Windows : Run the Python script as an administrator. macOS/Linux : Execute the script with sudo or ensure the user has sufficient permissions. Example: python sdsio-server.py usb --workdir ./work_dir SDS-View The Python utility SDS-View outputs a time-based plot of SDS data files ( <name>.<index>.sds ) based on the meta-data file ( <name>.sds.yml ). The horizontal time scale is derived from the number of data points in a recording and frequency provided in the metadata description. All plots form a single recording will be displayed on the same figure (shared vertical scale). If there are 3 values described in the metadata file, an optional 3D view may be displayed. Limitations Data in recording must all be of the same type (float, uint32_t, uint16_t, ...) Usage Setup the Python environment. Invoke the tool as explained below. usage: sds-view.py [-h] -y <yaml_file> -s <sds_file> [<sds_file> ...] [--3D] View SDS data options: -h, --help show this help message and exit required: -y <yaml_file> YAML sensor description file -s <sds_file> [<sds_file> ...] SDS data recording file optional: --3D Plot 3D view in addition to normal 2D Example: python sds-view.py -y test/Gyroscope.sds.yml -s test/Gyroscope.0.sds Example display: SDS-Convert The Python utility SDS-Convert converts SDS data files to selected format based on description in metadata (YAML) files. Usage Setup the Python environment. Depending on the required format use the tool as shown below. Audio WAV The audio_wav mode converts raw microphone data from .sds files into a standard RIFF/WAV file using linear PCM encoding. The conversion process involves appending a WAV header, generated from parameters specified in the associated metadata .yml file, to the raw audio data extracted from the .sds stream. The metadata defines essential audio parameters such as channel configuration (mono or stereo), sample rate (frame rate), and sample width (bit depth). usage: sds-convert.py audio_wav [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file Note The metadata and SDS data file pairs must be passed as arguments in the same order to decode the data correctly. The tool expects the SDS stream to be strictly audio - no header markers or custom formatting. Example of metadata yml file for mono microphone: sds: name: Microphone description: Mono microphone with 16kHz sample rate frequency: 16000 content: - value: Mono type: int16_t Example of metadata yml file for stereo microphone: sds: name: Microphone description: Stereo microphone with 16kHz sample rate frequency: 16000 content: - value: Left channel type: int16_t - value: Right channel type: int16_t Example: python sds-convert.py audio_wav -i Microphone.0.sds -o microphone.wav -y Microphone.sds.yml Simple CSV The simple_csv mode converts sensor data from .sds files into a human-readable CSV format. This mode is designed for exporting data from a single sensor. If the sensor has multiple channels, each channel will appear as a separate column in the output CSV. Timestamps are represented in floating-point format, in seconds. Using the --normalize flag causes all timestamps in the input file to be offset so that the first timestamp is 0 . Users may specify a time range selection of the input data to be processed using the following flags: --start-timestamp <timestamp> : Starting input data timestamp in floating-point format, in seconds. --stop-timestamp <timestamp> : Stopping input data timestamp in floating-point format, in seconds. usage: sds-convert.py simple_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-timestamp <timestamp>] [--stop-timestamp <timestamp>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-timestamp <timestamp> Starting input data timestamp, in seconds (default: None) --stop-timestamp <timestamp> Stopping input data timestamp, in seconds (default: None) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decode the data correctly. Current implementation assumes that the tick frequency is 1ms and does not use the tick-frequency value from the metadata file. Example of metadata yml file for gyroscope: sds: name: Gyroscope description: Gyroscope with 1667Hz sample rate frequency: 1667 content: - value: x type: int16_t scale: 0.07 unit: dps - value: y type: int16_t scale: 0.07 unit: dps - value: z type: int16_t scale: 0.07 unit: dps Example: python sds-convert.py simple_csv -i Gyroscope.0.sds -o gyroscope_simple.csv -y Gyroscope.sds.yml --normalize --start-tick 0.2 --stop-tick 0.3 Qeexo V2 CSV Timestamps are represented in integer format, in milliseconds. Using the --normalize flag causes all timestamps in the input file to be offset so that the first timestamp is 0 . Users may specify a time range selection of the input data to be processed using the following flags: --start-timestamp <timestamp> : Starting input data timestamp in integer format, in milliseconds. --stop-timestamp <timestamp> : Stopping input data timestamp in integer format, in milliseconds. By default, the output file will have raw timestamps in integer format, in milliseconds. The default output timestamp interval is set to 50 ms . To override this setting use the --interval <ms> flag, where <ms> is the desired interval in milliseconds. An optional label can be added to the output by providing a string argument to the --label <text> flag. This <text> will populate the label column in the output file. Link to Qeexo V2 CSV format specification . usage: sds-convert.py qeexo_v2_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-timestamp <timestamp>] [--stop-timestamp <timestamp>] [--label 'label'] [--interval <interval>] [--sds_index <sds_index>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-timestamp <timestamp> Starting input data timestamp, in ms (default: None) --stop-timestamp <timestamp> Stopping input data timestamp, in ms (default: None) --label 'label' Qeexo class label for sensor data (default: None) --interval <interval> Qeexo timestamp interval, in ms (default: 50) --sds_index <sds_index> SDS file index to write (default: <sensor>.0.sds) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decode the data correctly. Current implementation assumes that the tick frequency is 1ms and does not use the tick-frequency value from the metadata file. Example of metadata yml file for accelerometer: sds: name: Accelerometer description: Accelerometer with 1667Hz sample rate frequency: 1667 content: - value: x type: int16_t scale: 0.000061 unit: G - value: y type: int16_t scale: 0.000061 unit: G - value: z type: int16_t scale: 0.000061 unit: G Examples: Convert SDS data files to Qeexo V2 CSV files: python sds-convert.py qeexo_v2_csv -i Gyroscope.0.sds Accelerometer.0.sds -o sensor_fusion.csv -y Gyroscope.sds.yaml Accelerometer.sds.yaml --normalize --start-tick 200 --stop-tick 300 Convert Qeexo V2 CSV files to SDS data files: python sds-convert qeexo_v2_csv -i accelerometer_data.csv -o accelerometer.sds SDS-Check The Python utility SDS-Check checks SDS data files for correctness and consistency. The following checks are performed: Size consistency check : data size of all records should match the size of the SDS file. Timestamp consistency check : verify that timestamps of the records are in ascending order. Jitter check : print the record with the largest deviation from the average timestamp interval. Delta time check : find the record with the largest timestamps difference from the following record. Duplicate timestamp check : find records that have identical timestamps. Usage Setup the Python environment. Invoke the tool as explained below. usage: sds-check.py [-h] -s <sds_file> SDS data validation options: -h, --help show this help message and exit required: -s <sds_file> SDS data recording file Example: python sds-check.py -s Accelerometer.0.sds File : Accelerometer.0.sds DataSize : 156.020 bytes Records : 289 BlockSize: 532 bytes Largest : 552 bytes Smallest : 462 bytes Interval : 50 ms DataRate : 10.640 byte/s Jitter : 0 ms Validation passed Note The time values assume an tick rate of 1000 Hz. Summary Report After processing the SDS data file, the SDS-Check utility prints a summary report with statistics: DataSize : total size of the data in bytes Records : total number of records BlockSize : average block size of a data record Largest : largest block size, if different from the average block size (optional) Smallest : smallest block size, if different from the average block size (optional) Interval : time interval of the recording in milliseconds DataRate : recorded data rate in bytes per second Jitter : deviation from the expected timestamps DeltaTime : largest difference of the neighboring timestamps, if deviating from the recording interval (optional) DupStamps : number of duplicated timestamps, if found (optional) Size consistency check This check processes the SDS data records and calculates the total size of the SDS data. It is the sum of all data records (header + data). This data size should match the size of the SDS file. If the sizes do not match this error is printed: Error: File size mismatch. Expected 360 bytes, but file contains 363 bytes. Timestamp consistency check This check processes the SDS records and ensures that the timestamps recorded in the records are arranged in ascending order. If the utility detects that the timestamp of the subsequent data record is lower than the current one, this error is printed: Error: Timestamp not in ascending order in record 23. Jitter check This check processes the SDS data records and searches for a maximum deviation of the recorded timestamps from the expected ones. If the deviation is found, the record number is saved. The maximum deviation is evaluated as jitter and printed out in the summary report. File : Gyroscope.0.sds DataSize : 153.334 bytes Records : 284 BlockSize: 532 bytes Largest : 606 bytes Smallest : 444 bytes Interval : 50 ms DataRate : 10.640 byte/s Jitter : 0 ms Validation passed Delta time check This check processes the SDS records and tries to find the largest difference in timestamps between two neighboring records, called DeltaTime . For normally recorded files, the delta time and the recording interval are identical, so no information about the delta time status is printed. If the delta time and the recording interval are not identical, i.e. a difference is detected, the record number is also saved and the DeltaTime is printed in the summary report. File : Temperature.0.sds DataSize : 360 bytes Records : 30 BlockSize: 4 bytes Interval : 1.024 ms DataRate : 4 byte/s Jitter : 59 ms, record 19 DeltaTime: 1.050 ms, record 2 Validation passed This is not an error, but a report of an anomaly. If the time delta is significantly larger than the sampling interval, e.g. many times longer, this may indicate that one or more data records are missing from the recorded file. Duplicate timestamp check This check processes the SDS records in search of duplicated timestamps. This means that the same timestamp is used in several consecutive data records. This may indicate that the recording loop in an embedded application is not set up correctly. It is also possible that duplicate timestamps are caused by unexpected thread delays in the embedded application. Duplicate timestamps are unusual in typical recording files. If multiple timestamps with the same value are found in the SDS file, DupStamps will be added in the summary report. File : DataInput.0.sds DataSize : 17.509.440 bytes Records : 47.580 BlockSize: 360 bytes Interval : 1 ms DataRate : 360.000 byte/s Jitter : 4 ms, record 4 DeltaTime: 5 ms, record 5 DupStamps: 4, record 1 Validation passed This is not an error, but a report of an anomaly. The report contains the number of records with the same timestamp and the position in the SDS file where the anomaly was detected (record number). Note Only the first occurrence of a duplicate timestamp is reported.","title":"Utilities"},{"location":"utilities.html#utilities","text":"The SDS-Framework includes the following utilities that are implemented in Python. SDSIO-Server: enables recording and playback of SDS data files via socket (TCP/IP), USB (Bulk transfer) or serial (UART) connection. SDS-View: graphical data viewer for SDS data files. SDS-Convert: convert SDS data files into CSV, Qeexo V2 CSV, or WAV format. SDS-Check: check SDS data files for correctness and consistency.","title":"Utilities"},{"location":"utilities.html#requirements","text":"Python 3.9 or later with packages: ifaddr matplotlib numpy pandas pyyaml pyserial libusb1","title":"Requirements"},{"location":"utilities.html#setup","text":"Verify the installed Python version with: python --version Option 1: Use a Python environment: python -m venv sds // create environment with name sds sds\\Scripts\\activate pip install -r requirements.txt Option 2: Install the required Python packages with pip : pip install ifaddr matplotlib numpy pandas pyyaml pyserial libusb1","title":"Setup"},{"location":"utilities.html#sdsio-server","text":"The Python utility SDSIO-Server enables recording and playback of SDS data files via socket (TCP/IP), USB (Bulk transfer), or serial (UART) connection. It communicates with the target using these SDSIO Client interfaces : serial/usart for serial communication via CMSIS-Driver USART. socket for TCP/IP communication via IoT Socket using MDK-Middleware, LwIP, or CMSIS-Driver WiFi. usb/bulk for communication via USB Bulk transfer using MDK-Middleware. The SDS data stream is recorded to files with the following naming convention: <name>.<index>.sds <name> is the name of the I/O stream specified with the function sdsRecOpen or sdsPlayOpen on the target. <index> is the zero-based index which is incremented for each subsequent recording. For more details see Filenames section The data content of the <name>.<index>.sds is described with metadata file <name>.sds.yml in YAML format .","title":"SDSIO-Server"},{"location":"utilities.html#usage","text":"Setup the Python environment. Depending on the SDS interface used on the target use either Serial Mode , Socket Mode or USB Mode as described below. The SDSIO_Server terminates with Ctrl+C .","title":"Usage"},{"location":"utilities.html#serial-mode","text":"usage: sdsio-server.py serial [-h] -p <Serial Port> [--baudrate <Baudrate>] [--parity <Parity>] [--stopbits <Stop bits>] [--connect-timeout <Timeout>] [--workdir <Work dir>] optional arguments: -h, --help show this help message and exit required: -p <Serial Port> Serial port optional: --baudrate <Baudrate> Baudrate (default: 115200) --parity <Parity> Parity: N=None, E=Even, O=Odd, M=Mark, S=Space (default: N) --stopbits <Stop bits> Stop bits: 1, 1.5, 2 (default: 1) --connect-timeout <Timeout> Serial port connection timeout in seconds (default: no timeout) --workdir <Work dir> Directory for SDS files (default: current directory) Example: python sdsio-server.py serial -p COM0 --baudrate 115200 --workdir ./work_dir","title":"Serial Mode"},{"location":"utilities.html#socket-mode","text":"usage: sdsio-server.py socket [-h] [--ipaddr <IP> | --interface <Interface>] [--port <TCP Port>] [--workdir <Work dir>] optional arguments: -h, --help show this help message and exit optional: --ipaddr <IP> Server IP address (cannot be used with --interface) --interface <Interface> Network interface (cannot be used with --ipaddr) --port <TCP Port> TCP port (default: 5050) --workdir <Work dir> Directory for SDS files (default: current directory) Note The --ipaddr and --interface options are mutually exclusive. SDSIO Server only supports IPv4 addresses. Example: For Microsoft Windows (using default computer IP): python sdsio-server.py socket --workdir ./work_dir For Linux: python sdsio-server.py socket --interface eth0 --workdir ./work_dir","title":"Socket Mode"},{"location":"utilities.html#usb-mode","text":"usage: sdsio-server.py usb [-h] [--workdir <Work dir>] [--high-priority] optional arguments: -h, --help show this help message and exit optional: --workdir <Work dir> Directory for SDS files (default: current directory) --high-priority Enable high-priority threading for USB server (default: off) Note For more reliable operation at higher data transfer rates, it is recommended to enable the --high-priority option. This increases the thread priority of the SDSIO-Server process. When using --high-priority , elevated privileges are required depending on your operating system: Windows : Run the Python script as an administrator. macOS/Linux : Execute the script with sudo or ensure the user has sufficient permissions. Example: python sdsio-server.py usb --workdir ./work_dir","title":"USB Mode"},{"location":"utilities.html#sds-view","text":"The Python utility SDS-View outputs a time-based plot of SDS data files ( <name>.<index>.sds ) based on the meta-data file ( <name>.sds.yml ). The horizontal time scale is derived from the number of data points in a recording and frequency provided in the metadata description. All plots form a single recording will be displayed on the same figure (shared vertical scale). If there are 3 values described in the metadata file, an optional 3D view may be displayed.","title":"SDS-View"},{"location":"utilities.html#limitations","text":"Data in recording must all be of the same type (float, uint32_t, uint16_t, ...)","title":"Limitations"},{"location":"utilities.html#usage_1","text":"Setup the Python environment. Invoke the tool as explained below. usage: sds-view.py [-h] -y <yaml_file> -s <sds_file> [<sds_file> ...] [--3D] View SDS data options: -h, --help show this help message and exit required: -y <yaml_file> YAML sensor description file -s <sds_file> [<sds_file> ...] SDS data recording file optional: --3D Plot 3D view in addition to normal 2D Example: python sds-view.py -y test/Gyroscope.sds.yml -s test/Gyroscope.0.sds Example display:","title":"Usage"},{"location":"utilities.html#sds-convert","text":"The Python utility SDS-Convert converts SDS data files to selected format based on description in metadata (YAML) files.","title":"SDS-Convert"},{"location":"utilities.html#usage_2","text":"Setup the Python environment. Depending on the required format use the tool as shown below.","title":"Usage"},{"location":"utilities.html#audio-wav","text":"The audio_wav mode converts raw microphone data from .sds files into a standard RIFF/WAV file using linear PCM encoding. The conversion process involves appending a WAV header, generated from parameters specified in the associated metadata .yml file, to the raw audio data extracted from the .sds stream. The metadata defines essential audio parameters such as channel configuration (mono or stereo), sample rate (frame rate), and sample width (bit depth). usage: sds-convert.py audio_wav [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file Note The metadata and SDS data file pairs must be passed as arguments in the same order to decode the data correctly. The tool expects the SDS stream to be strictly audio - no header markers or custom formatting. Example of metadata yml file for mono microphone: sds: name: Microphone description: Mono microphone with 16kHz sample rate frequency: 16000 content: - value: Mono type: int16_t Example of metadata yml file for stereo microphone: sds: name: Microphone description: Stereo microphone with 16kHz sample rate frequency: 16000 content: - value: Left channel type: int16_t - value: Right channel type: int16_t Example: python sds-convert.py audio_wav -i Microphone.0.sds -o microphone.wav -y Microphone.sds.yml","title":"Audio WAV"},{"location":"utilities.html#simple-csv","text":"The simple_csv mode converts sensor data from .sds files into a human-readable CSV format. This mode is designed for exporting data from a single sensor. If the sensor has multiple channels, each channel will appear as a separate column in the output CSV. Timestamps are represented in floating-point format, in seconds. Using the --normalize flag causes all timestamps in the input file to be offset so that the first timestamp is 0 . Users may specify a time range selection of the input data to be processed using the following flags: --start-timestamp <timestamp> : Starting input data timestamp in floating-point format, in seconds. --stop-timestamp <timestamp> : Stopping input data timestamp in floating-point format, in seconds. usage: sds-convert.py simple_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-timestamp <timestamp>] [--stop-timestamp <timestamp>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-timestamp <timestamp> Starting input data timestamp, in seconds (default: None) --stop-timestamp <timestamp> Stopping input data timestamp, in seconds (default: None) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decode the data correctly. Current implementation assumes that the tick frequency is 1ms and does not use the tick-frequency value from the metadata file. Example of metadata yml file for gyroscope: sds: name: Gyroscope description: Gyroscope with 1667Hz sample rate frequency: 1667 content: - value: x type: int16_t scale: 0.07 unit: dps - value: y type: int16_t scale: 0.07 unit: dps - value: z type: int16_t scale: 0.07 unit: dps Example: python sds-convert.py simple_csv -i Gyroscope.0.sds -o gyroscope_simple.csv -y Gyroscope.sds.yml --normalize --start-tick 0.2 --stop-tick 0.3","title":"Simple CSV"},{"location":"utilities.html#qeexo-v2-csv","text":"Timestamps are represented in integer format, in milliseconds. Using the --normalize flag causes all timestamps in the input file to be offset so that the first timestamp is 0 . Users may specify a time range selection of the input data to be processed using the following flags: --start-timestamp <timestamp> : Starting input data timestamp in integer format, in milliseconds. --stop-timestamp <timestamp> : Stopping input data timestamp in integer format, in milliseconds. By default, the output file will have raw timestamps in integer format, in milliseconds. The default output timestamp interval is set to 50 ms . To override this setting use the --interval <ms> flag, where <ms> is the desired interval in milliseconds. An optional label can be added to the output by providing a string argument to the --label <text> flag. This <text> will populate the label column in the output file. Link to Qeexo V2 CSV format specification . usage: sds-convert.py qeexo_v2_csv [-h] -i <input_file> [<input_file> ...] -o <output_file> [-y <yaml_file> [<yaml_file> ...]] [--normalize] [--start-timestamp <timestamp>] [--stop-timestamp <timestamp>] [--label 'label'] [--interval <interval>] [--sds_index <sds_index>] options: -h, --help show this help message and exit required: -i <input_file> [<input_file> ...] Input file -o <output_file> Output file optional: -y <yaml_file> [<yaml_file> ...] YAML sensor description file --normalize Normalize timestamps so they start with 0 --start-timestamp <timestamp> Starting input data timestamp, in ms (default: None) --stop-timestamp <timestamp> Stopping input data timestamp, in ms (default: None) --label 'label' Qeexo class label for sensor data (default: None) --interval <interval> Qeexo timestamp interval, in ms (default: 50) --sds_index <sds_index> SDS file index to write (default: <sensor>.0.sds) Note The metadata and SDS data file pairs must be passed as arguments in the same order to decode the data correctly. Current implementation assumes that the tick frequency is 1ms and does not use the tick-frequency value from the metadata file. Example of metadata yml file for accelerometer: sds: name: Accelerometer description: Accelerometer with 1667Hz sample rate frequency: 1667 content: - value: x type: int16_t scale: 0.000061 unit: G - value: y type: int16_t scale: 0.000061 unit: G - value: z type: int16_t scale: 0.000061 unit: G Examples: Convert SDS data files to Qeexo V2 CSV files: python sds-convert.py qeexo_v2_csv -i Gyroscope.0.sds Accelerometer.0.sds -o sensor_fusion.csv -y Gyroscope.sds.yaml Accelerometer.sds.yaml --normalize --start-tick 200 --stop-tick 300 Convert Qeexo V2 CSV files to SDS data files: python sds-convert qeexo_v2_csv -i accelerometer_data.csv -o accelerometer.sds","title":"Qeexo V2 CSV"},{"location":"utilities.html#sds-check","text":"The Python utility SDS-Check checks SDS data files for correctness and consistency. The following checks are performed: Size consistency check : data size of all records should match the size of the SDS file. Timestamp consistency check : verify that timestamps of the records are in ascending order. Jitter check : print the record with the largest deviation from the average timestamp interval. Delta time check : find the record with the largest timestamps difference from the following record. Duplicate timestamp check : find records that have identical timestamps.","title":"SDS-Check"},{"location":"utilities.html#usage_3","text":"Setup the Python environment. Invoke the tool as explained below. usage: sds-check.py [-h] -s <sds_file> SDS data validation options: -h, --help show this help message and exit required: -s <sds_file> SDS data recording file Example: python sds-check.py -s Accelerometer.0.sds File : Accelerometer.0.sds DataSize : 156.020 bytes Records : 289 BlockSize: 532 bytes Largest : 552 bytes Smallest : 462 bytes Interval : 50 ms DataRate : 10.640 byte/s Jitter : 0 ms Validation passed Note The time values assume an tick rate of 1000 Hz.","title":"Usage"},{"location":"utilities.html#summary-report","text":"After processing the SDS data file, the SDS-Check utility prints a summary report with statistics: DataSize : total size of the data in bytes Records : total number of records BlockSize : average block size of a data record Largest : largest block size, if different from the average block size (optional) Smallest : smallest block size, if different from the average block size (optional) Interval : time interval of the recording in milliseconds DataRate : recorded data rate in bytes per second Jitter : deviation from the expected timestamps DeltaTime : largest difference of the neighboring timestamps, if deviating from the recording interval (optional) DupStamps : number of duplicated timestamps, if found (optional)","title":"Summary Report"},{"location":"utilities.html#size-consistency-check","text":"This check processes the SDS data records and calculates the total size of the SDS data. It is the sum of all data records (header + data). This data size should match the size of the SDS file. If the sizes do not match this error is printed: Error: File size mismatch. Expected 360 bytes, but file contains 363 bytes.","title":"Size consistency check"},{"location":"utilities.html#timestamp-consistency-check","text":"This check processes the SDS records and ensures that the timestamps recorded in the records are arranged in ascending order. If the utility detects that the timestamp of the subsequent data record is lower than the current one, this error is printed: Error: Timestamp not in ascending order in record 23.","title":"Timestamp consistency check"},{"location":"utilities.html#jitter-check","text":"This check processes the SDS data records and searches for a maximum deviation of the recorded timestamps from the expected ones. If the deviation is found, the record number is saved. The maximum deviation is evaluated as jitter and printed out in the summary report. File : Gyroscope.0.sds DataSize : 153.334 bytes Records : 284 BlockSize: 532 bytes Largest : 606 bytes Smallest : 444 bytes Interval : 50 ms DataRate : 10.640 byte/s Jitter : 0 ms Validation passed","title":"Jitter check"},{"location":"utilities.html#delta-time-check","text":"This check processes the SDS records and tries to find the largest difference in timestamps between two neighboring records, called DeltaTime . For normally recorded files, the delta time and the recording interval are identical, so no information about the delta time status is printed. If the delta time and the recording interval are not identical, i.e. a difference is detected, the record number is also saved and the DeltaTime is printed in the summary report. File : Temperature.0.sds DataSize : 360 bytes Records : 30 BlockSize: 4 bytes Interval : 1.024 ms DataRate : 4 byte/s Jitter : 59 ms, record 19 DeltaTime: 1.050 ms, record 2 Validation passed This is not an error, but a report of an anomaly. If the time delta is significantly larger than the sampling interval, e.g. many times longer, this may indicate that one or more data records are missing from the recorded file.","title":"Delta time check"},{"location":"utilities.html#duplicate-timestamp-check","text":"This check processes the SDS records in search of duplicated timestamps. This means that the same timestamp is used in several consecutive data records. This may indicate that the recording loop in an embedded application is not set up correctly. It is also possible that duplicate timestamps are caused by unexpected thread delays in the embedded application. Duplicate timestamps are unusual in typical recording files. If multiple timestamps with the same value are found in the SDS file, DupStamps will be added in the summary report. File : DataInput.0.sds DataSize : 17.509.440 bytes Records : 47.580 BlockSize: 360 bytes Interval : 1 ms DataRate : 360.000 byte/s Jitter : 4 ms, record 4 DeltaTime: 5 ms, record 5 DupStamps: 4, record 1 Validation passed This is not an error, but a report of an anomaly. The report contains the number of records with the same timestamp and the position in the SDS file where the anomaly was detected (record number). Note Only the first occurrence of a duplicate timestamp is reported.","title":"Duplicate timestamp check"},{"location":"SDS_API/annotated.html","text":"Class List Here are the classes, structs, unions and interfaces with brief descriptions: struct header_t","title":"Class List"},{"location":"SDS_API/annotated.html#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: struct header_t","title":"Class List"},{"location":"SDS_API/files.html","text":"File List Here is a list of all files with brief descriptions: dir sds dir include file sds_buffer.h file sds_rec_play.h file sdsio.h file sdsio_client.h file sds.txt","title":"File List"},{"location":"SDS_API/files.html#file-list","text":"Here is a list of all files with brief descriptions: dir sds dir include file sds_buffer.h file sds_rec_play.h file sdsio.h file sdsio_client.h file sds.txt","title":"File List"},{"location":"SDS_API/structheader__t.html","text":"Struct header_t ClassList > header_t Public Attributes Type Name uint32_t argument uint32_t command uint32_t data_size uint32_t sdsio_id Public Attributes Documentation variable argument uint32_t header_t::argument; variable command uint32_t header_t::command; variable data_size uint32_t header_t::data_size; variable sdsio_id uint32_t header_t::sdsio_id; The documentation for this class was generated from the following file sds/include/sdsio_client.h","title":"Struct header_t"},{"location":"SDS_API/structheader__t.html#struct-header_t","text":"ClassList > header_t","title":"Struct header_t"},{"location":"SDS_API/structheader__t.html#public-attributes","text":"Type Name uint32_t argument uint32_t command uint32_t data_size uint32_t sdsio_id","title":"Public Attributes"},{"location":"SDS_API/structheader__t.html#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"SDS_API/structheader__t.html#variable-argument","text":"uint32_t header_t::argument;","title":"variable argument"},{"location":"SDS_API/structheader__t.html#variable-command","text":"uint32_t header_t::command;","title":"variable command"},{"location":"SDS_API/structheader__t.html#variable-data_size","text":"uint32_t header_t::data_size;","title":"variable data_size"},{"location":"SDS_API/structheader__t.html#variable-sdsio_id","text":"uint32_t header_t::sdsio_id; The documentation for this class was generated from the following file sds/include/sdsio_client.h","title":"variable sdsio_id"},{"location":"SDS_API/group__SDS__Buffer.html","text":"Group SDS_Buffer Modules > SDS_Buffer sds_buffer.h : SDS circular buffer handling for data streams More... Modules Type Name module Event Codes SDS Buffer Event Codes. module Function Return Codes SDS Buffer Function Return Codes. Public Types Type Name typedef void(* sdsBufferEvent_t Callback function for SDS circular buffer event handling. typedef void * sdsBufferId_t Handle to SDS circular buffer. Public Functions Type Name int32_t sdsBufferClear ( sdsBufferId_t id) Clear SDS buffer stream data. int32_t sdsBufferClose ( sdsBufferId_t id) Close SDS buffer stream. int32_t sdsBufferGetCount ( sdsBufferId_t id) Get data count in SDS buffer stream. sdsBufferId_t sdsBufferOpen (void * buf, uint32_t buf_size, uint32_t threshold_low, uint32_t threshold_high) Open SDS buffer stream. int32_t sdsBufferRead ( sdsBufferId_t id, void * buf, uint32_t buf_size) Read data from SDS buffer stream. int32_t sdsBufferRegisterEvents ( sdsBufferId_t id, sdsBufferEvent_t event_cb, uint32_t event_mask, void * event_arg) Register SDS buffer stream event callback function. int32_t sdsBufferWrite ( sdsBufferId_t id, const void * buf, uint32_t buf_size) Write data to SDS buffer stream. Detailed Description The SDS circular Buffer provides an interface for managing circular buffer streams used for efficient data transfer between software components. It includes functions for opening, closing, reading, writing, clearing, and monitoring buffer states using event callbacks. Each buffer stream is represented by an identifier of type sdsBufferId_t , which is obtained via sdsBufferOpen() and used in subsequent API calls to refer to the corresponding buffer instance. Buffer Behavior The buffer operates as a circular FIFO (first-in, first-out) queue. Data written to the buffer via sdsBufferWrite() is stored until read by sdsBufferRead() or until the buffer is cleared or closed. The buffer supports thresholds (threshold_low and threshold_high) for monitoring usage levels and triggering user-defined events. Thread Safety The SDS Buffer API is partially thread-safe, with the following constraints: Thread-safe operations: sdsBufferRead() sdsBufferWrite() sdsBufferGetCount() These functions may be safely called concurrently, provided they operate on the same buffer instance ( sdsBufferId_t ). This allows safe producer-consumer models where one thread writes and another reads from the same buffer. Non-thread-safe operations: sdsBufferOpen() sdsBufferClose() sdsBufferClear() sdsBufferRegisterEvents() These functions must not be called concurrently with each other or with sdsBufferRead() or sdsBufferWrite() for the same buffer. Doing so can lead to undefined behavior or data corruption. Public Types Documentation typedef sdsBufferEvent_t Callback function for SDS circular buffer event handling. typedef void(* sdsBufferEvent_t) (sdsBufferId_t id, uint32_t event, void *arg); This function is registered by passing a pointer to it as a parameter to the sdsBufferRegisterEvents function. It is invoked when the circular buffer either reaches or exceeds the high data threshold or falls to or below the low data threshold. The high and low data thresholds are configured using the sdsBufferOpen function. Parameters: id sdsBufferId_t handle to SDS buffer stream event event code (see Event Codes ) arg pointer to argument registered with sdsBufferRegisterEvents typedef sdsBufferId_t Handle to SDS circular buffer. typedef void* sdsBufferId_t; This pointer defines the handle to SDS circular buffer. It is used to identify a circular buffer across the different functions. Public Functions Documentation function sdsBufferClear Clear SDS buffer stream data. int32_t sdsBufferClear ( sdsBufferId_t id ) Clears any data from the SDS circular buffer and resets the circular buffer to empty state. Parameters: id sdsBufferId_t handle to SDS buffer stream Returns: SDS_BUFFER_OK on success or a negative value on error (see Function Return Codes ) function sdsBufferClose Close SDS buffer stream. int32_t sdsBufferClose ( sdsBufferId_t id ) Closes the SDS circular buffer when read or write operations are no longer required. Parameters: id sdsBufferId_t handle to SDS buffer stream Returns: SDS_BUFFER_OK on success or a negative value on error (see Function Return Codes ) function sdsBufferGetCount Get data count in SDS buffer stream. int32_t sdsBufferGetCount ( sdsBufferId_t id ) Retrieves the number of data bytes currently available in the SDS circular buffer. Parameters: id sdsBufferId_t handle to SDS buffer stream Returns: number of data bytes available in buffer stream or a negative value on error (see Function Return Codes ) function sdsBufferOpen Open SDS buffer stream. sdsBufferId_t sdsBufferOpen ( void * buf, uint32_t buf_size, uint32_t threshold_low, uint32_t threshold_high ) Opens the SDS circular buffer for read or write operations. The function returns the handle to the SDS buffer stream; if the buffer could not be opened, it returns NULL. Parameters: buf pointer to buffer for stream buf_size buffer size in bytes threshold_low data low threshold in bytes threshold_high data high threshold in bytes Returns: sdsBufferId_t Handle to SDS buffer stream, or NULL if operation failed function sdsBufferRead Read data from SDS buffer stream. int32_t sdsBufferRead ( sdsBufferId_t id, void * buf, uint32_t buf_size ) Attempts to read up to buf_size bytes of data from the SDS circular buffer into a buf . If sufficient data is available, the requested number of bytes will be read. If only partial data is available, only the available bytes will be read. On success, the function returns the number of bytes actually read or 0 if SDS circular buffer is empty. Parameters: id sdsBufferId_t handle to SDS buffer stream buf pointer to buffer for data to read buf_size buffer size in bytes Returns: number of data bytes successfully read or a negative value on error (see Function Return Codes ) function sdsBufferRegisterEvents Register SDS buffer stream event callback function. int32_t sdsBufferRegisterEvents ( sdsBufferId_t id, sdsBufferEvent_t event_cb, uint32_t event_mask, void * event_arg ) Registers a sdsBufferEvent_t callback function to handle threshold events for the specified SDS buffer. The event_mask parameter specifies which buffer events should trigger the callback. It is a bitmask composed of values from the Event Codes enumeration: SDS_BUFFER_EVENT_DATA_LOW SDS_BUFFER_EVENT_DATA_HIGH When an event matching the mask occurs, the registered event_cb function is invoked with event_arg as its context. If event_cb is NULL, any previously registered callback for the specified buffer is unregistered. Parameters: id sdsBufferId_t handle to SDS buffer stream event_cb pointer to sdsBufferEvent_t callback function, NULL to un-register event_mask event mask event_arg pointer to event argument Returns: SDS_BUFFER_OK on success or a negative value on error (see Function Return Codes ) function sdsBufferWrite Write data to SDS buffer stream. int32_t sdsBufferWrite ( sdsBufferId_t id, const void * buf, uint32_t buf_size ) Attempts to write up to buf_size bytes of data from buf to the SDS circular buffer. If sufficient space is available in the buffer, all data will be written. If only partial space is available, only the number of bytes that fit will be written. No data is overwritten. On success, the function returns the number of bytes actually written. Parameters: id sdsBufferId_t handle to SDS buffer stream buf pointer to buffer with data to write buf_size buffer size in bytes Returns: number of data bytes successfully written or a negative value on error (see Function Return Codes )","title":"Group SDS_Buffer"},{"location":"SDS_API/group__SDS__Buffer.html#group-sds_buffer","text":"Modules > SDS_Buffer sds_buffer.h : SDS circular buffer handling for data streams More...","title":"Group SDS_Buffer"},{"location":"SDS_API/group__SDS__Buffer.html#modules","text":"Type Name module Event Codes SDS Buffer Event Codes. module Function Return Codes SDS Buffer Function Return Codes.","title":"Modules"},{"location":"SDS_API/group__SDS__Buffer.html#public-types","text":"Type Name typedef void(* sdsBufferEvent_t Callback function for SDS circular buffer event handling. typedef void * sdsBufferId_t Handle to SDS circular buffer.","title":"Public Types"},{"location":"SDS_API/group__SDS__Buffer.html#public-functions","text":"Type Name int32_t sdsBufferClear ( sdsBufferId_t id) Clear SDS buffer stream data. int32_t sdsBufferClose ( sdsBufferId_t id) Close SDS buffer stream. int32_t sdsBufferGetCount ( sdsBufferId_t id) Get data count in SDS buffer stream. sdsBufferId_t sdsBufferOpen (void * buf, uint32_t buf_size, uint32_t threshold_low, uint32_t threshold_high) Open SDS buffer stream. int32_t sdsBufferRead ( sdsBufferId_t id, void * buf, uint32_t buf_size) Read data from SDS buffer stream. int32_t sdsBufferRegisterEvents ( sdsBufferId_t id, sdsBufferEvent_t event_cb, uint32_t event_mask, void * event_arg) Register SDS buffer stream event callback function. int32_t sdsBufferWrite ( sdsBufferId_t id, const void * buf, uint32_t buf_size) Write data to SDS buffer stream.","title":"Public Functions"},{"location":"SDS_API/group__SDS__Buffer.html#detailed-description","text":"The SDS circular Buffer provides an interface for managing circular buffer streams used for efficient data transfer between software components. It includes functions for opening, closing, reading, writing, clearing, and monitoring buffer states using event callbacks. Each buffer stream is represented by an identifier of type sdsBufferId_t , which is obtained via sdsBufferOpen() and used in subsequent API calls to refer to the corresponding buffer instance. Buffer Behavior The buffer operates as a circular FIFO (first-in, first-out) queue. Data written to the buffer via sdsBufferWrite() is stored until read by sdsBufferRead() or until the buffer is cleared or closed. The buffer supports thresholds (threshold_low and threshold_high) for monitoring usage levels and triggering user-defined events. Thread Safety The SDS Buffer API is partially thread-safe, with the following constraints: Thread-safe operations: sdsBufferRead() sdsBufferWrite() sdsBufferGetCount() These functions may be safely called concurrently, provided they operate on the same buffer instance ( sdsBufferId_t ). This allows safe producer-consumer models where one thread writes and another reads from the same buffer. Non-thread-safe operations: sdsBufferOpen() sdsBufferClose() sdsBufferClear() sdsBufferRegisterEvents() These functions must not be called concurrently with each other or with sdsBufferRead() or sdsBufferWrite() for the same buffer. Doing so can lead to undefined behavior or data corruption.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__Buffer.html#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"SDS_API/group__SDS__Buffer.html#typedef-sdsbufferevent_t","text":"Callback function for SDS circular buffer event handling. typedef void(* sdsBufferEvent_t) (sdsBufferId_t id, uint32_t event, void *arg); This function is registered by passing a pointer to it as a parameter to the sdsBufferRegisterEvents function. It is invoked when the circular buffer either reaches or exceeds the high data threshold or falls to or below the low data threshold. The high and low data thresholds are configured using the sdsBufferOpen function. Parameters: id sdsBufferId_t handle to SDS buffer stream event event code (see Event Codes ) arg pointer to argument registered with sdsBufferRegisterEvents","title":"typedef sdsBufferEvent_t"},{"location":"SDS_API/group__SDS__Buffer.html#typedef-sdsbufferid_t","text":"Handle to SDS circular buffer. typedef void* sdsBufferId_t; This pointer defines the handle to SDS circular buffer. It is used to identify a circular buffer across the different functions.","title":"typedef sdsBufferId_t"},{"location":"SDS_API/group__SDS__Buffer.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbufferclear","text":"Clear SDS buffer stream data. int32_t sdsBufferClear ( sdsBufferId_t id ) Clears any data from the SDS circular buffer and resets the circular buffer to empty state. Parameters: id sdsBufferId_t handle to SDS buffer stream Returns: SDS_BUFFER_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsBufferClear"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbufferclose","text":"Close SDS buffer stream. int32_t sdsBufferClose ( sdsBufferId_t id ) Closes the SDS circular buffer when read or write operations are no longer required. Parameters: id sdsBufferId_t handle to SDS buffer stream Returns: SDS_BUFFER_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsBufferClose"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbuffergetcount","text":"Get data count in SDS buffer stream. int32_t sdsBufferGetCount ( sdsBufferId_t id ) Retrieves the number of data bytes currently available in the SDS circular buffer. Parameters: id sdsBufferId_t handle to SDS buffer stream Returns: number of data bytes available in buffer stream or a negative value on error (see Function Return Codes )","title":"function sdsBufferGetCount"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbufferopen","text":"Open SDS buffer stream. sdsBufferId_t sdsBufferOpen ( void * buf, uint32_t buf_size, uint32_t threshold_low, uint32_t threshold_high ) Opens the SDS circular buffer for read or write operations. The function returns the handle to the SDS buffer stream; if the buffer could not be opened, it returns NULL. Parameters: buf pointer to buffer for stream buf_size buffer size in bytes threshold_low data low threshold in bytes threshold_high data high threshold in bytes Returns: sdsBufferId_t Handle to SDS buffer stream, or NULL if operation failed","title":"function sdsBufferOpen"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbufferread","text":"Read data from SDS buffer stream. int32_t sdsBufferRead ( sdsBufferId_t id, void * buf, uint32_t buf_size ) Attempts to read up to buf_size bytes of data from the SDS circular buffer into a buf . If sufficient data is available, the requested number of bytes will be read. If only partial data is available, only the available bytes will be read. On success, the function returns the number of bytes actually read or 0 if SDS circular buffer is empty. Parameters: id sdsBufferId_t handle to SDS buffer stream buf pointer to buffer for data to read buf_size buffer size in bytes Returns: number of data bytes successfully read or a negative value on error (see Function Return Codes )","title":"function sdsBufferRead"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbufferregisterevents","text":"Register SDS buffer stream event callback function. int32_t sdsBufferRegisterEvents ( sdsBufferId_t id, sdsBufferEvent_t event_cb, uint32_t event_mask, void * event_arg ) Registers a sdsBufferEvent_t callback function to handle threshold events for the specified SDS buffer. The event_mask parameter specifies which buffer events should trigger the callback. It is a bitmask composed of values from the Event Codes enumeration: SDS_BUFFER_EVENT_DATA_LOW SDS_BUFFER_EVENT_DATA_HIGH When an event matching the mask occurs, the registered event_cb function is invoked with event_arg as its context. If event_cb is NULL, any previously registered callback for the specified buffer is unregistered. Parameters: id sdsBufferId_t handle to SDS buffer stream event_cb pointer to sdsBufferEvent_t callback function, NULL to un-register event_mask event mask event_arg pointer to event argument Returns: SDS_BUFFER_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsBufferRegisterEvents"},{"location":"SDS_API/group__SDS__Buffer.html#function-sdsbufferwrite","text":"Write data to SDS buffer stream. int32_t sdsBufferWrite ( sdsBufferId_t id, const void * buf, uint32_t buf_size ) Attempts to write up to buf_size bytes of data from buf to the SDS circular buffer. If sufficient space is available in the buffer, all data will be written. If only partial space is available, only the number of bytes that fit will be written. No data is overwritten. On success, the function returns the number of bytes actually written. Parameters: id sdsBufferId_t handle to SDS buffer stream buf pointer to buffer with data to write buf_size buffer size in bytes Returns: number of data bytes successfully written or a negative value on error (see Function Return Codes )","title":"function sdsBufferWrite"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html","text":"Group SDS_Buffer_Event_Codes Modules > SDS_Buffer_Event_Codes SDS Buffer Event Codes. More... Macros Type Name define SDS_BUFFER_EVENT_DATA_HIGH (2UL) Event signaled when data in circular buffer reaches or exceeds high threshold value. define SDS_BUFFER_EVENT_DATA_LOW (1UL) Event signaled when data in circular buffer falls to or below low threshold value. Detailed Description The following values are passed as event value to sdsBufferEvent_t callback function. Macro Definition Documentation define SDS_BUFFER_EVENT_DATA_HIGH Event signaled when data in circular buffer reaches or exceeds high threshold value. #define SDS_BUFFER_EVENT_DATA_HIGH `(2UL)` define SDS_BUFFER_EVENT_DATA_LOW Event signaled when data in circular buffer falls to or below low threshold value. #define SDS_BUFFER_EVENT_DATA_LOW `(1UL)`","title":"Group SDS_Buffer_Event_Codes"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html#group-sds_buffer_event_codes","text":"Modules > SDS_Buffer_Event_Codes SDS Buffer Event Codes. More...","title":"Group SDS_Buffer_Event_Codes"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html#macros","text":"Type Name define SDS_BUFFER_EVENT_DATA_HIGH (2UL) Event signaled when data in circular buffer reaches or exceeds high threshold value. define SDS_BUFFER_EVENT_DATA_LOW (1UL) Event signaled when data in circular buffer falls to or below low threshold value.","title":"Macros"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html#detailed-description","text":"The following values are passed as event value to sdsBufferEvent_t callback function.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html#define-sds_buffer_event_data_high","text":"Event signaled when data in circular buffer reaches or exceeds high threshold value. #define SDS_BUFFER_EVENT_DATA_HIGH `(2UL)`","title":"define SDS_BUFFER_EVENT_DATA_HIGH"},{"location":"SDS_API/group__SDS__Buffer__Event__Codes.html#define-sds_buffer_event_data_low","text":"Event signaled when data in circular buffer falls to or below low threshold value. #define SDS_BUFFER_EVENT_DATA_LOW `(1UL)`","title":"define SDS_BUFFER_EVENT_DATA_LOW"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html","text":"Group SDS_Buffer_Return_Codes Modules > SDS_Buffer_Return_Codes SDS Buffer Function Return Codes. More... Macros Type Name define SDS_BUFFER_ERROR (-1) Error during sdsBuffer function execution. define SDS_BUFFER_ERROR_PARAMETER (-2) Error due to invalid parameter passed to an sdsBuffer function. define SDS_BUFFER_OK (0) sdsBuffer function execution completed successfully. Detailed Description The following values are returned by most sdsBuffer functions. Macro Definition Documentation define SDS_BUFFER_ERROR Error during sdsBuffer function execution. #define SDS_BUFFER_ERROR `(-1)` define SDS_BUFFER_ERROR_PARAMETER Error due to invalid parameter passed to an sdsBuffer function. #define SDS_BUFFER_ERROR_PARAMETER `(-2)` define SDS_BUFFER_OK sdsBuffer function execution completed successfully. #define SDS_BUFFER_OK `(0)`","title":"Group SDS_Buffer_Return_Codes"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#group-sds_buffer_return_codes","text":"Modules > SDS_Buffer_Return_Codes SDS Buffer Function Return Codes. More...","title":"Group SDS_Buffer_Return_Codes"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#macros","text":"Type Name define SDS_BUFFER_ERROR (-1) Error during sdsBuffer function execution. define SDS_BUFFER_ERROR_PARAMETER (-2) Error due to invalid parameter passed to an sdsBuffer function. define SDS_BUFFER_OK (0) sdsBuffer function execution completed successfully.","title":"Macros"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#detailed-description","text":"The following values are returned by most sdsBuffer functions.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#define-sds_buffer_error","text":"Error during sdsBuffer function execution. #define SDS_BUFFER_ERROR `(-1)`","title":"define SDS_BUFFER_ERROR"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#define-sds_buffer_error_parameter","text":"Error due to invalid parameter passed to an sdsBuffer function. #define SDS_BUFFER_ERROR_PARAMETER `(-2)`","title":"define SDS_BUFFER_ERROR_PARAMETER"},{"location":"SDS_API/group__SDS__Buffer__Return__Codes.html#define-sds_buffer_ok","text":"sdsBuffer function execution completed successfully. #define SDS_BUFFER_OK `(0)`","title":"define SDS_BUFFER_OK"},{"location":"SDS_API/group__SDS__IO__Interface.html","text":"Group SDS_IO_Interface Modules > SDS_IO_Interface sdsio.h : SDS I/O Interface for data streams More... Modules Type Name module Function Return Codes SDS I/O Function Return Codes. Public Types Type Name typedef void * sdsioId_t Handle to SDS I/O data stream. enum sdsioMode_t Public Functions Type Name int32_t sdsioClose ( sdsioId_t id) Close I/O stream. int32_t sdsioInit (void) Initialize SDS I/O. sdsioId_t sdsioOpen (const char * name, sdsioMode_t mode) Open I/O stream. int32_t sdsioRead ( sdsioId_t id, void * buf, uint32_t buf_size) Read data from I/O stream. int32_t sdsioUninit (void) Un-initialize SDS I/O. int32_t sdsioWrite ( sdsioId_t id, const void * buf, uint32_t buf_size) Write data to I/O stream. Detailed Description The SDS I/O interface provides a generic mechanism for reading from and writing to SDS file s using several I/O backends. Interface can operate over: A local file system, such as an SD card or semihosting, where files are accessed directly. A communication channel such as Ethernet, USB, or UART, where access to files is performed remotely via an SDS I/O Server. When using a communication channel, the embedded device runs an SDS I/O Client, which communicates with the SDS I/O Server running on the host machine. This interaction is command-based (e.g., SDSIO_CMD_OPEN , SDSIO_CMD_READ , SDSIO_CMD_WRITE ) and enables the embedded system to remotely open, read, write, and close files located on the host. For more details, refer to SDSIO Server Protocol . The interface is lightweight and backend-agnostic, making it suitable for embedded data logging, host-interactive tools, or as a transport layer for higher-level components such as the SDS Recorder and Player. Public Types Documentation typedef sdsioId_t Handle to SDS I/O data stream. typedef void* sdsioId_t; This pointer defines the handle to SDS I/O data stream. It is used to identify a data stream across the different functions. enum sdsioMode_t enum sdsioMode_t { sdsioModeRead = 0, sdsioModeWrite = 1 }; This enum identifies the read or write mode to SDS I/O data streams. It is a parameter of the sdsioOpen function. Public Functions Documentation function sdsioClose Close I/O stream. int32_t sdsioClose ( sdsioId_t id ) Closes an SDS I/O stream. If the interface is a local file system or semihosting, the file is closed directly. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends a close command (SDSIO_CMD_CLOSE) to the SDS I/O Server to close the file on the Host system. Parameters: id sdsioId_t handle to SDS I/O stream Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes ) function sdsioInit Initialize SDS I/O. int32_t sdsioInit ( void ) Initializes the SDS I/O interface. The interface may be a local file system (e.g., an SD card) or semihosting, or a communication channel such as Ethernet, USB or UART. In the case of a communication channel, the SDS I/O Client is used to interact with the SDS I/O Server running on a Host machine. The initialization process includes setting up the communication interface and verifying that the I/O Server is active on the Host. Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes ) function sdsioOpen Open I/O stream. sdsioId_t sdsioOpen ( const char * name, sdsioMode_t mode ) Opens an SDS I/O stream for reading or writing. If the interface is a local file system or semihosting, the file is opened directly. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends an open command (SDSIO_CMD_OPEN) to the SDS I/O Server to open the file on the Host system. The function returns the handle to the SDS I/O stream; if the I/O stream could not be opened, it returns NULL. Parameters: name stream name (pointer to NULL terminated string) mode sdsioMode_t open mode Returns: sdsioId_t Handle to SDS I/O stream, or NULL if operation failed function sdsioRead Read data from I/O stream. int32_t sdsioRead ( sdsioId_t id, void * buf, uint32_t buf_size ) Attempts to read up to buf_size bytes of data from the SDS I/O stream identified by id into the memory pointed to buf . If the interface is a local file system or semihosting, data is read directly from the file. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends a read command (SDSIO_CMD_READ) to the SDS I/O Server, which reads the file on the Host system and returns the data to the Client. The function attempts to read data and may block based on the behavior of the underlying interface and data availability. It returns under the following conditions: If data is available, the function reads up to buf_size bytes and returns the number of bytes actually read. This value may be less than buf_size . If no data becomes available before the timeout expires, the function returns SDSIO_ERROR_TIMEOUT . If data is partially read but the timeout occurs before the full request is satisfied, the function returns the number of bytes read up to that point. If the end of the stream is reached and no more data remains, the function returns SDSIO_EOS to indicate that the end of file has been reached and no additional data is available. If an I/O interface or protocol error occurs, the function returns SDSIO_ERROR or SDSIO_ERROR_INTERFACE . Parameters: id sdsioId_t handle to SDS I/O stream buf pointer to buffer for data to read buf_size buffer size in bytes Returns: number of bytes successfully read, or a negative value on error or EOS (see Function Return Codes ) function sdsioUninit Un-initialize SDS I/O. int32_t sdsioUninit ( void ) De-initializes the SDS I/O interface. If a communication channel such as Ethernet, USB or USART is used, the corresponding communication interface is also de-initialized. Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes ) function sdsioWrite Write data to I/O stream. int32_t sdsioWrite ( sdsioId_t id, const void * buf, uint32_t buf_size ) Attempts to write up to buf_size bytes from the memory pointed to buf to the SDS I/O stream identified by id . If the interface is a local file system or semihosting, data is written directly to the file. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends a write command (SDSIO_CMD_WRITE) along with the data to the SDS I/O Server, which then writes the data to a file on the Host system. The function may return before all data has been written, depending on the available interface bandwidth, buffer capacity, or timeout behavior: If the write operation is successful, the function returns the number of bytes actually written. This value may be less than buf_size in case of partial write. If no data could be written before the operation times out, the function returns SDSIO_ERROR_TIMEOUT . If an I/O interface or protocol error occurs, the function returns SDSIO_ERROR or SDSIO_ERROR_INTERFACE . Parameters: id sdsioId_t handle to SDS I/O stream buf pointer to buffer with data to write buf_size buffer size in bytes Returns: number of bytes successfully written or a negative value on error (see Function Return Codes )","title":"Group SDS_IO_Interface"},{"location":"SDS_API/group__SDS__IO__Interface.html#group-sds_io_interface","text":"Modules > SDS_IO_Interface sdsio.h : SDS I/O Interface for data streams More...","title":"Group SDS_IO_Interface"},{"location":"SDS_API/group__SDS__IO__Interface.html#modules","text":"Type Name module Function Return Codes SDS I/O Function Return Codes.","title":"Modules"},{"location":"SDS_API/group__SDS__IO__Interface.html#public-types","text":"Type Name typedef void * sdsioId_t Handle to SDS I/O data stream. enum sdsioMode_t","title":"Public Types"},{"location":"SDS_API/group__SDS__IO__Interface.html#public-functions","text":"Type Name int32_t sdsioClose ( sdsioId_t id) Close I/O stream. int32_t sdsioInit (void) Initialize SDS I/O. sdsioId_t sdsioOpen (const char * name, sdsioMode_t mode) Open I/O stream. int32_t sdsioRead ( sdsioId_t id, void * buf, uint32_t buf_size) Read data from I/O stream. int32_t sdsioUninit (void) Un-initialize SDS I/O. int32_t sdsioWrite ( sdsioId_t id, const void * buf, uint32_t buf_size) Write data to I/O stream.","title":"Public Functions"},{"location":"SDS_API/group__SDS__IO__Interface.html#detailed-description","text":"The SDS I/O interface provides a generic mechanism for reading from and writing to SDS file s using several I/O backends. Interface can operate over: A local file system, such as an SD card or semihosting, where files are accessed directly. A communication channel such as Ethernet, USB, or UART, where access to files is performed remotely via an SDS I/O Server. When using a communication channel, the embedded device runs an SDS I/O Client, which communicates with the SDS I/O Server running on the host machine. This interaction is command-based (e.g., SDSIO_CMD_OPEN , SDSIO_CMD_READ , SDSIO_CMD_WRITE ) and enables the embedded system to remotely open, read, write, and close files located on the host. For more details, refer to SDSIO Server Protocol . The interface is lightweight and backend-agnostic, making it suitable for embedded data logging, host-interactive tools, or as a transport layer for higher-level components such as the SDS Recorder and Player.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__IO__Interface.html#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"SDS_API/group__SDS__IO__Interface.html#typedef-sdsioid_t","text":"Handle to SDS I/O data stream. typedef void* sdsioId_t; This pointer defines the handle to SDS I/O data stream. It is used to identify a data stream across the different functions.","title":"typedef sdsioId_t"},{"location":"SDS_API/group__SDS__IO__Interface.html#enum-sdsiomode_t","text":"enum sdsioMode_t { sdsioModeRead = 0, sdsioModeWrite = 1 }; This enum identifies the read or write mode to SDS I/O data streams. It is a parameter of the sdsioOpen function.","title":"enum sdsioMode_t"},{"location":"SDS_API/group__SDS__IO__Interface.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"SDS_API/group__SDS__IO__Interface.html#function-sdsioclose","text":"Close I/O stream. int32_t sdsioClose ( sdsioId_t id ) Closes an SDS I/O stream. If the interface is a local file system or semihosting, the file is closed directly. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends a close command (SDSIO_CMD_CLOSE) to the SDS I/O Server to close the file on the Host system. Parameters: id sdsioId_t handle to SDS I/O stream Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsioClose"},{"location":"SDS_API/group__SDS__IO__Interface.html#function-sdsioinit","text":"Initialize SDS I/O. int32_t sdsioInit ( void ) Initializes the SDS I/O interface. The interface may be a local file system (e.g., an SD card) or semihosting, or a communication channel such as Ethernet, USB or UART. In the case of a communication channel, the SDS I/O Client is used to interact with the SDS I/O Server running on a Host machine. The initialization process includes setting up the communication interface and verifying that the I/O Server is active on the Host. Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsioInit"},{"location":"SDS_API/group__SDS__IO__Interface.html#function-sdsioopen","text":"Open I/O stream. sdsioId_t sdsioOpen ( const char * name, sdsioMode_t mode ) Opens an SDS I/O stream for reading or writing. If the interface is a local file system or semihosting, the file is opened directly. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends an open command (SDSIO_CMD_OPEN) to the SDS I/O Server to open the file on the Host system. The function returns the handle to the SDS I/O stream; if the I/O stream could not be opened, it returns NULL. Parameters: name stream name (pointer to NULL terminated string) mode sdsioMode_t open mode Returns: sdsioId_t Handle to SDS I/O stream, or NULL if operation failed","title":"function sdsioOpen"},{"location":"SDS_API/group__SDS__IO__Interface.html#function-sdsioread","text":"Read data from I/O stream. int32_t sdsioRead ( sdsioId_t id, void * buf, uint32_t buf_size ) Attempts to read up to buf_size bytes of data from the SDS I/O stream identified by id into the memory pointed to buf . If the interface is a local file system or semihosting, data is read directly from the file. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends a read command (SDSIO_CMD_READ) to the SDS I/O Server, which reads the file on the Host system and returns the data to the Client. The function attempts to read data and may block based on the behavior of the underlying interface and data availability. It returns under the following conditions: If data is available, the function reads up to buf_size bytes and returns the number of bytes actually read. This value may be less than buf_size . If no data becomes available before the timeout expires, the function returns SDSIO_ERROR_TIMEOUT . If data is partially read but the timeout occurs before the full request is satisfied, the function returns the number of bytes read up to that point. If the end of the stream is reached and no more data remains, the function returns SDSIO_EOS to indicate that the end of file has been reached and no additional data is available. If an I/O interface or protocol error occurs, the function returns SDSIO_ERROR or SDSIO_ERROR_INTERFACE . Parameters: id sdsioId_t handle to SDS I/O stream buf pointer to buffer for data to read buf_size buffer size in bytes Returns: number of bytes successfully read, or a negative value on error or EOS (see Function Return Codes )","title":"function sdsioRead"},{"location":"SDS_API/group__SDS__IO__Interface.html#function-sdsiouninit","text":"Un-initialize SDS I/O. int32_t sdsioUninit ( void ) De-initializes the SDS I/O interface. If a communication channel such as Ethernet, USB or USART is used, the corresponding communication interface is also de-initialized. Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsioUninit"},{"location":"SDS_API/group__SDS__IO__Interface.html#function-sdsiowrite","text":"Write data to I/O stream. int32_t sdsioWrite ( sdsioId_t id, const void * buf, uint32_t buf_size ) Attempts to write up to buf_size bytes from the memory pointed to buf to the SDS I/O stream identified by id . If the interface is a local file system or semihosting, data is written directly to the file. For communication channels such as Ethernet, USB or USART, the SDS I/O Client sends a write command (SDSIO_CMD_WRITE) along with the data to the SDS I/O Server, which then writes the data to a file on the Host system. The function may return before all data has been written, depending on the available interface bandwidth, buffer capacity, or timeout behavior: If the write operation is successful, the function returns the number of bytes actually written. This value may be less than buf_size in case of partial write. If no data could be written before the operation times out, the function returns SDSIO_ERROR_TIMEOUT . If an I/O interface or protocol error occurs, the function returns SDSIO_ERROR or SDSIO_ERROR_INTERFACE . Parameters: id sdsioId_t handle to SDS I/O stream buf pointer to buffer with data to write buf_size buffer size in bytes Returns: number of bytes successfully written or a negative value on error (see Function Return Codes )","title":"function sdsioWrite"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html","text":"Group SDS_IO_Return_Codes Modules > SDS_IO_Return_Codes SDS I/O Function Return Codes. More... Macros Type Name define SDSIO_EOS (-6) End of stream reached in SDS I/O read operation. define SDSIO_ERROR (-1) General error during SDS I/O function execution. define SDSIO_ERROR_INTERFACE (-4) Error in the SDS I/O interface. define SDSIO_ERROR_NO_SERVER (-5) No response from the SDS I/O server. define SDSIO_ERROR_PARAMETER (-2) Invalid parameter passed to an SDS I/O function. define SDSIO_ERROR_TIMEOUT (-3) SDS I/O function execution timed out. define SDSIO_OK (0) SDS I/O function executed successfully. Detailed Description The following values are returned by most sdsio functions. Macro Definition Documentation define SDSIO_EOS End of stream reached in SDS I/O read operation. #define SDSIO_EOS `(-6)` define SDSIO_ERROR General error during SDS I/O function execution. #define SDSIO_ERROR `(-1)` define SDSIO_ERROR_INTERFACE Error in the SDS I/O interface. #define SDSIO_ERROR_INTERFACE `(-4)` define SDSIO_ERROR_NO_SERVER No response from the SDS I/O server. #define SDSIO_ERROR_NO_SERVER `(-5)` define SDSIO_ERROR_PARAMETER Invalid parameter passed to an SDS I/O function. #define SDSIO_ERROR_PARAMETER `(-2)` define SDSIO_ERROR_TIMEOUT SDS I/O function execution timed out. #define SDSIO_ERROR_TIMEOUT `(-3)` define SDSIO_OK SDS I/O function executed successfully. #define SDSIO_OK `(0)`","title":"Group SDS_IO_Return_Codes"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#group-sds_io_return_codes","text":"Modules > SDS_IO_Return_Codes SDS I/O Function Return Codes. More...","title":"Group SDS_IO_Return_Codes"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#macros","text":"Type Name define SDSIO_EOS (-6) End of stream reached in SDS I/O read operation. define SDSIO_ERROR (-1) General error during SDS I/O function execution. define SDSIO_ERROR_INTERFACE (-4) Error in the SDS I/O interface. define SDSIO_ERROR_NO_SERVER (-5) No response from the SDS I/O server. define SDSIO_ERROR_PARAMETER (-2) Invalid parameter passed to an SDS I/O function. define SDSIO_ERROR_TIMEOUT (-3) SDS I/O function execution timed out. define SDSIO_OK (0) SDS I/O function executed successfully.","title":"Macros"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#detailed-description","text":"The following values are returned by most sdsio functions.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_eos","text":"End of stream reached in SDS I/O read operation. #define SDSIO_EOS `(-6)`","title":"define SDSIO_EOS"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_error","text":"General error during SDS I/O function execution. #define SDSIO_ERROR `(-1)`","title":"define SDSIO_ERROR"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_error_interface","text":"Error in the SDS I/O interface. #define SDSIO_ERROR_INTERFACE `(-4)`","title":"define SDSIO_ERROR_INTERFACE"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_error_no_server","text":"No response from the SDS I/O server. #define SDSIO_ERROR_NO_SERVER `(-5)`","title":"define SDSIO_ERROR_NO_SERVER"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_error_parameter","text":"Invalid parameter passed to an SDS I/O function. #define SDSIO_ERROR_PARAMETER `(-2)`","title":"define SDSIO_ERROR_PARAMETER"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_error_timeout","text":"SDS I/O function execution timed out. #define SDSIO_ERROR_TIMEOUT `(-3)`","title":"define SDSIO_ERROR_TIMEOUT"},{"location":"SDS_API/group__SDS__IO__Return__Codes.html#define-sdsio_ok","text":"SDS I/O function executed successfully. #define SDSIO_OK `(0)`","title":"define SDSIO_OK"},{"location":"SDS_API/group__SDS__Recorder__Player.html","text":"Group SDS_Recorder_Player Modules > SDS_Recorder_Player sds_rec_play.h : SDS Recorder and Player for writing and reading SDS files via communication or file I/O interface. More... Modules Type Name module Event Codes SDS Recorder and Player Event Codes. module Function Return Codes SDS Recorder and Player Function Return Codes. Public Types Type Name typedef void(* sdsRecPlayEvent_t Callback function for recorder and player events. typedef void * sdsRecPlayId_t Handle to SDS recorder or player stream. Public Functions Type Name int32_t sdsPlayClose ( sdsRecPlayId_t id) Close player stream. int32_t sdsPlayGetSize ( sdsRecPlayId_t id) Get data block size from Player stream. sdsRecPlayId_t sdsPlayOpen (const char * name, void * buf, uint32_t buf_size) Open player stream (read mode). int32_t sdsPlayRead ( sdsRecPlayId_t id, uint32_t * timestamp, void * buf, uint32_t buf_size) Read entire data block along with its timestamp from the player stream. int32_t sdsRecClose ( sdsRecPlayId_t id) Close recorder stream. sdsRecPlayId_t sdsRecOpen (const char * name, void * buf, uint32_t buf_size) Open recorder stream (write mode). int32_t sdsRecPlayInit ( sdsRecPlayEvent_t event_cb) Initialize recorder and player. int32_t sdsRecPlayUninit (void) Uninitialize recorder and player. int32_t sdsRecWrite ( sdsRecPlayId_t id, uint32_t timestamp, const void * buf, uint32_t buf_size) Write entire data block along with its timestamp to the recorder stream. Detailed Description The SDS Recorder and Player manage writing to and reading from SDS files through communication or file I/O interfaces. They support the recording and playback of real-world data for applications such as machine learning and data analysis. Refer to the chapter SDS Interface for an overview. The system uses a dedicated worker thread ( sdsRecPlayThread ) to handle file I/O asynchronously. User-facing APIs interact only with internal circular buffers, allowing efficient, non-blocking data operations. Each recorder or player stream is identified by a handle of type sdsRecPlayId_t , returned by sdsRecOpen or sdsPlayOpen , and is required for all subsequent operations on that stream. Thread Safety The SDS Recorder and Player are thread-safe for regular operation: A single thread may read from or write to a specific stream at a time. Multiple streams can be used concurrently by separate threads without conflict. While operational calls are thread-safe, improper reuse of closed streams can lead to data corruption : When a stream is closed via sdsRecPlayClose, its internal control block may be reallocated if another stream is opened. If a read or write operation is still pending on a handle after it has been closed, and a new stream is opened that causes control block reuse, the pending operation may unexpectedly complete on the newly opened stream . To prevent such issues: Avoid opening a new stream immediately after closing another unless you can guarantee that all references and asynchronous operations related to the previous stream have been fully completed or canceled. Public Types Documentation typedef sdsRecPlayEvent_t Callback function for recorder and player events. typedef void(* sdsRecPlayEvent_t) (sdsRecPlayId_t id, uint32_t event); This function is registered by passing a pointer to it as a parameter to the sdsRecPlayInit function. It is invoked when an error happens during recording or playback. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream event event code (see Event Codes ) typedef sdsRecPlayId_t Handle to SDS recorder or player stream. typedef void* sdsRecPlayId_t; This pointer defines the handle to SDS recorder or player stream. It is used to identify a data stream across the different functions for the SDS Recorder and Player system. Public Functions Documentation function sdsPlayClose Close player stream. int32_t sdsPlayClose ( sdsRecPlayId_t id ) Closes a player stream. The function waits for all pending data transfers to complete or until a timeout occurs. Upon successful closure, the stream handle becomes invalid. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes ) function sdsPlayGetSize Get data block size from Player stream. int32_t sdsPlayGetSize ( sdsRecPlayId_t id ) Function verifies that the entire header and the complete data block specified by the header are both present in the SDS circular buffer. It returns the size, in bytes, of the next available data block in the player stream. If either the header is incomplete or the corresponding data block is not yet fully available, the function returns SDS_PLAY_ERROR_NO_DATA . If the end of the stream has been reached and no further data is available, the function returns SDS_PLAY_EOS . Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream Returns: number of bytes in next available data block, or a negative value on error or EOS (see Function Return Codes ) function sdsPlayOpen Open player stream (read mode). sdsRecPlayId_t sdsPlayOpen ( const char * name, void * buf, uint32_t buf_size ) Opens a player stream for reading timestamps and data blocks from an SDS file. The buf parameter specifies a user-allocated memory region used as an internal circular buffer. The buffer must be large enough to accommodate the largest expected data block plus 8 bytes for the record header. The name parameter specifies the base name of the SDS input file. The function attempts to locate and open the file <name>.<index>.sds , where <index> is an auto-incrementing value. If no matching file is found, the function returns an error. For details, refer to Filenames section . This function may block for a period of time while it loads the internal SDS circular buffer with data from the SDS file. This function returns a handle that uniquely identifies the stream. The handle is used as a reference in subsequent function calls to perform operations on the stream. Parameters: name stream name (pointer to NULL terminated string) buf pointer to buffer for player stream buf_size buffer size in bytes Returns: sdsRecPlayId_t handle to SDS Recorder/Player stream, or NULL if operation failed function sdsPlayRead Read entire data block along with its timestamp from the player stream. int32_t sdsPlayRead ( sdsRecPlayId_t id, uint32_t * timestamp, void * buf, uint32_t buf_size ) Reads a data block along with its associated timestamp from the internal SDS circular buffer. The sdsRecPlayThread worker thread asynchronously reads the data from the SDS file using the underlying SDS I/O interface. For details on how the specific SDS file is selected, refer to Filenames section . The retrieved data is then written to the internal SDS circular buffer. This asynchronous design enables efficient, non-blocking data handling and ensures optimal performance. Before attempting to read, the function verifies that the entire header and the complete data block specified by the header are both present in the SDS circular buffer. If either the header is incomplete or the corresponding data block is not yet fully available, the function aborts and returns SDS_PLAY_ERROR_NO_DATA . The function verifies that the user-provided buffer buf , with size buf_size , is large enough to accommodate the entire data block. If it is too small, the function aborts and returns SDS_REC_PLAY_ERROR_PARAMETER . If the end of the stream has been reached and no further data is available, the function returns SDS_PLAY_EOS . On success, the function reads the data block from the circular buffer, stores it in the user-provided buffer, and returns the the size of the data block in bytes. The associated timestamp is returned via the output parameter timestamp . Thread safety is ensured by allowing only a single thread to read from a given stream at a time. However, multiple threads can concurrently read from different streams, enabling parallel operations across multiple streams. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream timestamp pointer to buffer for a timestamp in ticks buf pointer to the data block buffer to be read buf_size size of the data block buffer in bytes Returns: number of bytes successfully read, or a negative value on error or EOS (see Function Return Codes ) function sdsRecClose Close recorder stream. int32_t sdsRecClose ( sdsRecPlayId_t id ) Closes a recorder stream. Prior to closing, any remaining data in the internal circular buffer is flushed to the SDS file. The function blocks until all data transfers are complete or a timeout occurs. Upon successful closure, the stream handle becomes invalid. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes ) function sdsRecOpen Open recorder stream (write mode). sdsRecPlayId_t sdsRecOpen ( const char * name, void * buf, uint32_t buf_size ) Opens a recorder stream for writing timestamps and data blocks to the SDS file. The buf parameter specifies a user-allocated memory region that serves as an internal circular buffer. The buffer must be large enough to hold at least the largest expected data block plus 8 bytes for the record header. The name parameter defines the base name for the SDS output file and is used to construct the full file name in the format name.index.sds . The index is an auto-incrementing value that ensures a unique file name is generated. If a file with the generated name already exists, the index is incremented until an unused name is found. For details, refer to Filenames section . This function returns a handle that uniquely identifies the stream. The handle is used as a reference in subsequent function calls to perform operations on the stream. Parameters: name stream name (pointer to NULL terminated string) buf pointer to buffer for recorder stream buf_size buffer size in bytes Returns: sdsRecPlayId_t handle to SDS Recorder/Player stream, or NULL if operation failed function sdsRecPlayInit Initialize recorder and player. int32_t sdsRecPlayInit ( sdsRecPlayEvent_t event_cb ) Initializes the SDS Recorder and Player system. This function allocates resources, initializes underlying SDS I/O interface and creates the sdsRecPlayThread worker thread. An optional callback function can be registered to receive notifications (e.g., I/O errors). This function must be called once before opening any recorder or player streams. Parameters: event_cb pointer to sdsRecPlayEvent_t callback function Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes ) function sdsRecPlayUninit Uninitialize recorder and player. int32_t sdsRecPlayUninit ( void ) De-initializes the SDS Recorder and Player system. This function terminates the sdsRecPlayThread worker thread, and releases the internal resources. All open recorder or player streams must be closed by the user before calling this function. After de-initialization, the system must be re-initialized before further use. Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes ) function sdsRecWrite Write entire data block along with its timestamp to the recorder stream. int32_t sdsRecWrite ( sdsRecPlayId_t id, uint32_t timestamp, const void * buf, uint32_t buf_size ) Writes a data block, including a header containing the timestamp and data block size, to the internal circular buffer. The sdsRecPlayThread worker thread asynchronously writes the data to the SDS file via the underlying SDS I/O interface. For an explanation of how the SDS Recorder selects and names the target SDS file, refer to Filenames section . This asynchronous design enables efficient, non-blocking data handling and optimized performance. Before attempting to write, function verifies that the entire header and the complete data block, provided via the buffer pointer buf and its size buf_size , can fit within the available space in the internal SDS circular buffer. If insufficient space is available, the operation is aborted and the function returns SDS_REC_ERROR_NO_SPACE . On success, the function writes the header and data block to the SDS circular buffer and returns the number of data bytes written, excluding the header. Thread safety is ensured by allowing only a single thread to write to a given stream at a time. However, multiple threads can concurrently write to different streams, enabling parallel operations across multiple streams. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream timestamp timestamp in ticks buf pointer to the data block buffer to be written buf_size size of the data block buffer in bytes Returns: number of bytes successfully written or a negative value on error (see Function Return Codes )","title":"Group SDS_Recorder_Player"},{"location":"SDS_API/group__SDS__Recorder__Player.html#group-sds_recorder_player","text":"Modules > SDS_Recorder_Player sds_rec_play.h : SDS Recorder and Player for writing and reading SDS files via communication or file I/O interface. More...","title":"Group SDS_Recorder_Player"},{"location":"SDS_API/group__SDS__Recorder__Player.html#modules","text":"Type Name module Event Codes SDS Recorder and Player Event Codes. module Function Return Codes SDS Recorder and Player Function Return Codes.","title":"Modules"},{"location":"SDS_API/group__SDS__Recorder__Player.html#public-types","text":"Type Name typedef void(* sdsRecPlayEvent_t Callback function for recorder and player events. typedef void * sdsRecPlayId_t Handle to SDS recorder or player stream.","title":"Public Types"},{"location":"SDS_API/group__SDS__Recorder__Player.html#public-functions","text":"Type Name int32_t sdsPlayClose ( sdsRecPlayId_t id) Close player stream. int32_t sdsPlayGetSize ( sdsRecPlayId_t id) Get data block size from Player stream. sdsRecPlayId_t sdsPlayOpen (const char * name, void * buf, uint32_t buf_size) Open player stream (read mode). int32_t sdsPlayRead ( sdsRecPlayId_t id, uint32_t * timestamp, void * buf, uint32_t buf_size) Read entire data block along with its timestamp from the player stream. int32_t sdsRecClose ( sdsRecPlayId_t id) Close recorder stream. sdsRecPlayId_t sdsRecOpen (const char * name, void * buf, uint32_t buf_size) Open recorder stream (write mode). int32_t sdsRecPlayInit ( sdsRecPlayEvent_t event_cb) Initialize recorder and player. int32_t sdsRecPlayUninit (void) Uninitialize recorder and player. int32_t sdsRecWrite ( sdsRecPlayId_t id, uint32_t timestamp, const void * buf, uint32_t buf_size) Write entire data block along with its timestamp to the recorder stream.","title":"Public Functions"},{"location":"SDS_API/group__SDS__Recorder__Player.html#detailed-description","text":"The SDS Recorder and Player manage writing to and reading from SDS files through communication or file I/O interfaces. They support the recording and playback of real-world data for applications such as machine learning and data analysis. Refer to the chapter SDS Interface for an overview. The system uses a dedicated worker thread ( sdsRecPlayThread ) to handle file I/O asynchronously. User-facing APIs interact only with internal circular buffers, allowing efficient, non-blocking data operations. Each recorder or player stream is identified by a handle of type sdsRecPlayId_t , returned by sdsRecOpen or sdsPlayOpen , and is required for all subsequent operations on that stream. Thread Safety The SDS Recorder and Player are thread-safe for regular operation: A single thread may read from or write to a specific stream at a time. Multiple streams can be used concurrently by separate threads without conflict. While operational calls are thread-safe, improper reuse of closed streams can lead to data corruption : When a stream is closed via sdsRecPlayClose, its internal control block may be reallocated if another stream is opened. If a read or write operation is still pending on a handle after it has been closed, and a new stream is opened that causes control block reuse, the pending operation may unexpectedly complete on the newly opened stream . To prevent such issues: Avoid opening a new stream immediately after closing another unless you can guarantee that all references and asynchronous operations related to the previous stream have been fully completed or canceled.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__Recorder__Player.html#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"SDS_API/group__SDS__Recorder__Player.html#typedef-sdsrecplayevent_t","text":"Callback function for recorder and player events. typedef void(* sdsRecPlayEvent_t) (sdsRecPlayId_t id, uint32_t event); This function is registered by passing a pointer to it as a parameter to the sdsRecPlayInit function. It is invoked when an error happens during recording or playback. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream event event code (see Event Codes )","title":"typedef sdsRecPlayEvent_t"},{"location":"SDS_API/group__SDS__Recorder__Player.html#typedef-sdsrecplayid_t","text":"Handle to SDS recorder or player stream. typedef void* sdsRecPlayId_t; This pointer defines the handle to SDS recorder or player stream. It is used to identify a data stream across the different functions for the SDS Recorder and Player system.","title":"typedef sdsRecPlayId_t"},{"location":"SDS_API/group__SDS__Recorder__Player.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsplayclose","text":"Close player stream. int32_t sdsPlayClose ( sdsRecPlayId_t id ) Closes a player stream. The function waits for all pending data transfers to complete or until a timeout occurs. Upon successful closure, the stream handle becomes invalid. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsPlayClose"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsplaygetsize","text":"Get data block size from Player stream. int32_t sdsPlayGetSize ( sdsRecPlayId_t id ) Function verifies that the entire header and the complete data block specified by the header are both present in the SDS circular buffer. It returns the size, in bytes, of the next available data block in the player stream. If either the header is incomplete or the corresponding data block is not yet fully available, the function returns SDS_PLAY_ERROR_NO_DATA . If the end of the stream has been reached and no further data is available, the function returns SDS_PLAY_EOS . Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream Returns: number of bytes in next available data block, or a negative value on error or EOS (see Function Return Codes )","title":"function sdsPlayGetSize"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsplayopen","text":"Open player stream (read mode). sdsRecPlayId_t sdsPlayOpen ( const char * name, void * buf, uint32_t buf_size ) Opens a player stream for reading timestamps and data blocks from an SDS file. The buf parameter specifies a user-allocated memory region used as an internal circular buffer. The buffer must be large enough to accommodate the largest expected data block plus 8 bytes for the record header. The name parameter specifies the base name of the SDS input file. The function attempts to locate and open the file <name>.<index>.sds , where <index> is an auto-incrementing value. If no matching file is found, the function returns an error. For details, refer to Filenames section . This function may block for a period of time while it loads the internal SDS circular buffer with data from the SDS file. This function returns a handle that uniquely identifies the stream. The handle is used as a reference in subsequent function calls to perform operations on the stream. Parameters: name stream name (pointer to NULL terminated string) buf pointer to buffer for player stream buf_size buffer size in bytes Returns: sdsRecPlayId_t handle to SDS Recorder/Player stream, or NULL if operation failed","title":"function sdsPlayOpen"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsplayread","text":"Read entire data block along with its timestamp from the player stream. int32_t sdsPlayRead ( sdsRecPlayId_t id, uint32_t * timestamp, void * buf, uint32_t buf_size ) Reads a data block along with its associated timestamp from the internal SDS circular buffer. The sdsRecPlayThread worker thread asynchronously reads the data from the SDS file using the underlying SDS I/O interface. For details on how the specific SDS file is selected, refer to Filenames section . The retrieved data is then written to the internal SDS circular buffer. This asynchronous design enables efficient, non-blocking data handling and ensures optimal performance. Before attempting to read, the function verifies that the entire header and the complete data block specified by the header are both present in the SDS circular buffer. If either the header is incomplete or the corresponding data block is not yet fully available, the function aborts and returns SDS_PLAY_ERROR_NO_DATA . The function verifies that the user-provided buffer buf , with size buf_size , is large enough to accommodate the entire data block. If it is too small, the function aborts and returns SDS_REC_PLAY_ERROR_PARAMETER . If the end of the stream has been reached and no further data is available, the function returns SDS_PLAY_EOS . On success, the function reads the data block from the circular buffer, stores it in the user-provided buffer, and returns the the size of the data block in bytes. The associated timestamp is returned via the output parameter timestamp . Thread safety is ensured by allowing only a single thread to read from a given stream at a time. However, multiple threads can concurrently read from different streams, enabling parallel operations across multiple streams. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream timestamp pointer to buffer for a timestamp in ticks buf pointer to the data block buffer to be read buf_size size of the data block buffer in bytes Returns: number of bytes successfully read, or a negative value on error or EOS (see Function Return Codes )","title":"function sdsPlayRead"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsrecclose","text":"Close recorder stream. int32_t sdsRecClose ( sdsRecPlayId_t id ) Closes a recorder stream. Prior to closing, any remaining data in the internal circular buffer is flushed to the SDS file. The function blocks until all data transfers are complete or a timeout occurs. Upon successful closure, the stream handle becomes invalid. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsRecClose"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsrecopen","text":"Open recorder stream (write mode). sdsRecPlayId_t sdsRecOpen ( const char * name, void * buf, uint32_t buf_size ) Opens a recorder stream for writing timestamps and data blocks to the SDS file. The buf parameter specifies a user-allocated memory region that serves as an internal circular buffer. The buffer must be large enough to hold at least the largest expected data block plus 8 bytes for the record header. The name parameter defines the base name for the SDS output file and is used to construct the full file name in the format name.index.sds . The index is an auto-incrementing value that ensures a unique file name is generated. If a file with the generated name already exists, the index is incremented until an unused name is found. For details, refer to Filenames section . This function returns a handle that uniquely identifies the stream. The handle is used as a reference in subsequent function calls to perform operations on the stream. Parameters: name stream name (pointer to NULL terminated string) buf pointer to buffer for recorder stream buf_size buffer size in bytes Returns: sdsRecPlayId_t handle to SDS Recorder/Player stream, or NULL if operation failed","title":"function sdsRecOpen"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsrecplayinit","text":"Initialize recorder and player. int32_t sdsRecPlayInit ( sdsRecPlayEvent_t event_cb ) Initializes the SDS Recorder and Player system. This function allocates resources, initializes underlying SDS I/O interface and creates the sdsRecPlayThread worker thread. An optional callback function can be registered to receive notifications (e.g., I/O errors). This function must be called once before opening any recorder or player streams. Parameters: event_cb pointer to sdsRecPlayEvent_t callback function Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsRecPlayInit"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsrecplayuninit","text":"Uninitialize recorder and player. int32_t sdsRecPlayUninit ( void ) De-initializes the SDS Recorder and Player system. This function terminates the sdsRecPlayThread worker thread, and releases the internal resources. All open recorder or player streams must be closed by the user before calling this function. After de-initialization, the system must be re-initialized before further use. Returns: SDS_REC_PLAY_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsRecPlayUninit"},{"location":"SDS_API/group__SDS__Recorder__Player.html#function-sdsrecwrite","text":"Write entire data block along with its timestamp to the recorder stream. int32_t sdsRecWrite ( sdsRecPlayId_t id, uint32_t timestamp, const void * buf, uint32_t buf_size ) Writes a data block, including a header containing the timestamp and data block size, to the internal circular buffer. The sdsRecPlayThread worker thread asynchronously writes the data to the SDS file via the underlying SDS I/O interface. For an explanation of how the SDS Recorder selects and names the target SDS file, refer to Filenames section . This asynchronous design enables efficient, non-blocking data handling and optimized performance. Before attempting to write, function verifies that the entire header and the complete data block, provided via the buffer pointer buf and its size buf_size , can fit within the available space in the internal SDS circular buffer. If insufficient space is available, the operation is aborted and the function returns SDS_REC_ERROR_NO_SPACE . On success, the function writes the header and data block to the SDS circular buffer and returns the number of data bytes written, excluding the header. Thread safety is ensured by allowing only a single thread to write to a given stream at a time. However, multiple threads can concurrently write to different streams, enabling parallel operations across multiple streams. Parameters: id sdsRecPlayId_t handle to SDS Recorder/Player stream timestamp timestamp in ticks buf pointer to the data block buffer to be written buf_size size of the data block buffer in bytes Returns: number of bytes successfully written or a negative value on error (see Function Return Codes )","title":"function sdsRecWrite"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html","text":"Group SDS_Recorder_Player_Event_Codes Modules > SDS_Recorder_Player_Event_Codes SDS Recorder and Player Event Codes. More... Macros Type Name define SDS_PLAY_EVENT_ERROR_NO_DATA (4UL) Event triggered when sdsPlayRead() fails due to insufficient data in the SDS circular buffer. define SDS_REC_EVENT_ERROR_NO_SPACE (2UL) Event triggered when sdsRecWrite() fails due to insufficient space in the SDS circular buffer. define SDS_REC_PLAY_EVENT_ERROR_IO (1UL) Event triggered when an I/O error occurs during recording or playback. Detailed Description The following values are passed as event value to sdsRecPlayEvent_t callback function. Macro Definition Documentation define SDS_PLAY_EVENT_ERROR_NO_DATA Event triggered when sdsPlayRead() fails due to insufficient data in the SDS circular buffer. #define SDS_PLAY_EVENT_ERROR_NO_DATA `(4UL)` define SDS_REC_EVENT_ERROR_NO_SPACE Event triggered when sdsRecWrite() fails due to insufficient space in the SDS circular buffer. #define SDS_REC_EVENT_ERROR_NO_SPACE `(2UL)` define SDS_REC_PLAY_EVENT_ERROR_IO Event triggered when an I/O error occurs during recording or playback. #define SDS_REC_PLAY_EVENT_ERROR_IO `(1UL)`","title":"Group SDS_Recorder_Player_Event_Codes"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#group-sds_recorder_player_event_codes","text":"Modules > SDS_Recorder_Player_Event_Codes SDS Recorder and Player Event Codes. More...","title":"Group SDS_Recorder_Player_Event_Codes"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#macros","text":"Type Name define SDS_PLAY_EVENT_ERROR_NO_DATA (4UL) Event triggered when sdsPlayRead() fails due to insufficient data in the SDS circular buffer. define SDS_REC_EVENT_ERROR_NO_SPACE (2UL) Event triggered when sdsRecWrite() fails due to insufficient space in the SDS circular buffer. define SDS_REC_PLAY_EVENT_ERROR_IO (1UL) Event triggered when an I/O error occurs during recording or playback.","title":"Macros"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#detailed-description","text":"The following values are passed as event value to sdsRecPlayEvent_t callback function.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#define-sds_play_event_error_no_data","text":"Event triggered when sdsPlayRead() fails due to insufficient data in the SDS circular buffer. #define SDS_PLAY_EVENT_ERROR_NO_DATA `(4UL)`","title":"define SDS_PLAY_EVENT_ERROR_NO_DATA"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#define-sds_rec_event_error_no_space","text":"Event triggered when sdsRecWrite() fails due to insufficient space in the SDS circular buffer. #define SDS_REC_EVENT_ERROR_NO_SPACE `(2UL)`","title":"define SDS_REC_EVENT_ERROR_NO_SPACE"},{"location":"SDS_API/group__SDS__Recorder__Player__Event__Codes.html#define-sds_rec_play_event_error_io","text":"Event triggered when an I/O error occurs during recording or playback. #define SDS_REC_PLAY_EVENT_ERROR_IO `(1UL)`","title":"define SDS_REC_PLAY_EVENT_ERROR_IO"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html","text":"Group SDS_Recorder_Player_Return_Codes Modules > SDS_Recorder_Player_Return_Codes SDS Recorder and Player Function Return Codes. More... Macros Type Name define SDS_PLAY_EOS (-7) End of stream reached in SDS Player operation. define SDS_PLAY_ERROR_NO_DATA (-6) Not whole data block is available in the SDS circular buffer. define SDS_REC_ERROR_NO_SPACE (-5) Insufficient space in SDS circular buffer to write the entire data block. define SDS_REC_PLAY_ERROR (-1) General error during SDS Recorder or Player function execution. define SDS_REC_PLAY_ERROR_IO (-4) I/O error during SDS Recorder or Player function execution. define SDS_REC_PLAY_ERROR_PARAMETER (-2) Invalid parameter passed to an SDS Recorder or Player function. define SDS_REC_PLAY_ERROR_TIMEOUT (-3) SDS Recorder or Player function execution timed out. define SDS_REC_PLAY_OK (0) SDS Recorder or Player function executed successfully. Detailed Description The following values are returned by most sdsRec and sdsPlay functions. Macro Definition Documentation define SDS_PLAY_EOS End of stream reached in SDS Player operation. #define SDS_PLAY_EOS `(-7)` define SDS_PLAY_ERROR_NO_DATA Not whole data block is available in the SDS circular buffer. #define SDS_PLAY_ERROR_NO_DATA `(-6)` define SDS_REC_ERROR_NO_SPACE Insufficient space in SDS circular buffer to write the entire data block. #define SDS_REC_ERROR_NO_SPACE `(-5)` define SDS_REC_PLAY_ERROR General error during SDS Recorder or Player function execution. #define SDS_REC_PLAY_ERROR `(-1)` define SDS_REC_PLAY_ERROR_IO I/O error during SDS Recorder or Player function execution. #define SDS_REC_PLAY_ERROR_IO `(-4)` define SDS_REC_PLAY_ERROR_PARAMETER Invalid parameter passed to an SDS Recorder or Player function. #define SDS_REC_PLAY_ERROR_PARAMETER `(-2)` define SDS_REC_PLAY_ERROR_TIMEOUT SDS Recorder or Player function execution timed out. #define SDS_REC_PLAY_ERROR_TIMEOUT `(-3)` define SDS_REC_PLAY_OK SDS Recorder or Player function executed successfully. #define SDS_REC_PLAY_OK `(0)`","title":"Group SDS_Recorder_Player_Return_Codes"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#group-sds_recorder_player_return_codes","text":"Modules > SDS_Recorder_Player_Return_Codes SDS Recorder and Player Function Return Codes. More...","title":"Group SDS_Recorder_Player_Return_Codes"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#macros","text":"Type Name define SDS_PLAY_EOS (-7) End of stream reached in SDS Player operation. define SDS_PLAY_ERROR_NO_DATA (-6) Not whole data block is available in the SDS circular buffer. define SDS_REC_ERROR_NO_SPACE (-5) Insufficient space in SDS circular buffer to write the entire data block. define SDS_REC_PLAY_ERROR (-1) General error during SDS Recorder or Player function execution. define SDS_REC_PLAY_ERROR_IO (-4) I/O error during SDS Recorder or Player function execution. define SDS_REC_PLAY_ERROR_PARAMETER (-2) Invalid parameter passed to an SDS Recorder or Player function. define SDS_REC_PLAY_ERROR_TIMEOUT (-3) SDS Recorder or Player function execution timed out. define SDS_REC_PLAY_OK (0) SDS Recorder or Player function executed successfully.","title":"Macros"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#detailed-description","text":"The following values are returned by most sdsRec and sdsPlay functions.","title":"Detailed Description"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_play_eos","text":"End of stream reached in SDS Player operation. #define SDS_PLAY_EOS `(-7)`","title":"define SDS_PLAY_EOS"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_play_error_no_data","text":"Not whole data block is available in the SDS circular buffer. #define SDS_PLAY_ERROR_NO_DATA `(-6)`","title":"define SDS_PLAY_ERROR_NO_DATA"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_rec_error_no_space","text":"Insufficient space in SDS circular buffer to write the entire data block. #define SDS_REC_ERROR_NO_SPACE `(-5)`","title":"define SDS_REC_ERROR_NO_SPACE"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_rec_play_error","text":"General error during SDS Recorder or Player function execution. #define SDS_REC_PLAY_ERROR `(-1)`","title":"define SDS_REC_PLAY_ERROR"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_rec_play_error_io","text":"I/O error during SDS Recorder or Player function execution. #define SDS_REC_PLAY_ERROR_IO `(-4)`","title":"define SDS_REC_PLAY_ERROR_IO"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_rec_play_error_parameter","text":"Invalid parameter passed to an SDS Recorder or Player function. #define SDS_REC_PLAY_ERROR_PARAMETER `(-2)`","title":"define SDS_REC_PLAY_ERROR_PARAMETER"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_rec_play_error_timeout","text":"SDS Recorder or Player function execution timed out. #define SDS_REC_PLAY_ERROR_TIMEOUT `(-3)`","title":"define SDS_REC_PLAY_ERROR_TIMEOUT"},{"location":"SDS_API/group__SDS__Recorder__Player__Return__Codes.html#define-sds_rec_play_ok","text":"SDS Recorder or Player function executed successfully. #define SDS_REC_PLAY_OK `(0)`","title":"define SDS_REC_PLAY_OK"},{"location":"SDS_API/dir_d8edc0eab7a99ea71a7d0245c268925a.html","text":"Dir sds FileList > sds Directories Type Name dir include The documentation for this class was generated from the following file sds/","title":"Dir sds"},{"location":"SDS_API/dir_d8edc0eab7a99ea71a7d0245c268925a.html#dir-sds","text":"FileList > sds","title":"Dir sds"},{"location":"SDS_API/dir_d8edc0eab7a99ea71a7d0245c268925a.html#directories","text":"Type Name dir include The documentation for this class was generated from the following file sds/","title":"Directories"},{"location":"SDS_API/dir_d09908635ef304ba819d3349bcb716bf.html","text":"Dir sds/include FileList > include Files Type Name file sds_buffer.h file sds_rec_play.h file sdsio.h file sdsio_client.h The documentation for this class was generated from the following file sds/include/","title":"Dir sds/include"},{"location":"SDS_API/dir_d09908635ef304ba819d3349bcb716bf.html#dir-sdsinclude","text":"FileList > include","title":"Dir sds/include"},{"location":"SDS_API/dir_d09908635ef304ba819d3349bcb716bf.html#files","text":"Type Name file sds_buffer.h file sds_rec_play.h file sdsio.h file sdsio_client.h The documentation for this class was generated from the following file sds/include/","title":"Files"},{"location":"SDS_API/sds__buffer_8h.html","text":"File sds_buffer.h FileList > include > sds_buffer.h Go to the source code of this file #include <stdint.h> The documentation for this class was generated from the following file sds/include/sds_buffer.h","title":"File sds_buffer.h"},{"location":"SDS_API/sds__buffer_8h.html#file-sds_bufferh","text":"FileList > include > sds_buffer.h Go to the source code of this file #include <stdint.h> The documentation for this class was generated from the following file sds/include/sds_buffer.h","title":"File sds_buffer.h"},{"location":"SDS_API/sds__buffer_8h_source.html","text":"File sds_buffer.h File List > include > sds_buffer.h Go to the documentation of this file /* * Copyright (c) 2022-2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDS_BUFFER_H #define SDS_BUFFER_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // ==== Synchronous Data Stream (SDS) Buffer ==== typedef void *sdsBufferId_t; // Handle to SDS buffer stream // Function return codes #define SDS_BUFFER_OK (0) // Operation completed successfully #define SDS_BUFFER_ERROR (-1) // Operation failed #define SDS_BUFFER_ERROR_PARAMETER (-2) // Operation failed: parameter error // Events #define SDS_BUFFER_EVENT_DATA_LOW (1UL) // Data size falls to or below low threshold #define SDS_BUFFER_EVENT_DATA_HIGH (2UL) // Data size reaches or exceeds high threshold typedef void (*sdsBufferEvent_t) (sdsBufferId_t id, uint32_t event, void *arg); sdsBufferId_t sdsBufferOpen (void *buf, uint32_t buf_size, uint32_t threshold_low, uint32_t threshold_high); int32_t sdsBufferClose (sdsBufferId_t id); int32_t sdsBufferRegisterEvents (sdsBufferId_t id, sdsBufferEvent_t event_cb, uint32_t event_mask, void *event_arg); int32_t sdsBufferWrite (sdsBufferId_t id, const void *buf, uint32_t buf_size); int32_t sdsBufferRead (sdsBufferId_t id, void *buf, uint32_t buf_size); int32_t sdsBufferClear (sdsBufferId_t id); int32_t sdsBufferGetCount (sdsBufferId_t id); #ifdef __cplusplus } #endif #endif /* SDS_BUFFER_H */","title":"File sds_buffer.h"},{"location":"SDS_API/sds__buffer_8h_source.html#file-sds_bufferh","text":"File List > include > sds_buffer.h Go to the documentation of this file /* * Copyright (c) 2022-2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDS_BUFFER_H #define SDS_BUFFER_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // ==== Synchronous Data Stream (SDS) Buffer ==== typedef void *sdsBufferId_t; // Handle to SDS buffer stream // Function return codes #define SDS_BUFFER_OK (0) // Operation completed successfully #define SDS_BUFFER_ERROR (-1) // Operation failed #define SDS_BUFFER_ERROR_PARAMETER (-2) // Operation failed: parameter error // Events #define SDS_BUFFER_EVENT_DATA_LOW (1UL) // Data size falls to or below low threshold #define SDS_BUFFER_EVENT_DATA_HIGH (2UL) // Data size reaches or exceeds high threshold typedef void (*sdsBufferEvent_t) (sdsBufferId_t id, uint32_t event, void *arg); sdsBufferId_t sdsBufferOpen (void *buf, uint32_t buf_size, uint32_t threshold_low, uint32_t threshold_high); int32_t sdsBufferClose (sdsBufferId_t id); int32_t sdsBufferRegisterEvents (sdsBufferId_t id, sdsBufferEvent_t event_cb, uint32_t event_mask, void *event_arg); int32_t sdsBufferWrite (sdsBufferId_t id, const void *buf, uint32_t buf_size); int32_t sdsBufferRead (sdsBufferId_t id, void *buf, uint32_t buf_size); int32_t sdsBufferClear (sdsBufferId_t id); int32_t sdsBufferGetCount (sdsBufferId_t id); #ifdef __cplusplus } #endif #endif /* SDS_BUFFER_H */","title":"File sds_buffer.h"},{"location":"SDS_API/sds__rec__play_8h.html","text":"File sds_rec_play.h FileList > include > sds_rec_play.h Go to the source code of this file #include <stdint.h> The documentation for this class was generated from the following file sds/include/sds_rec_play.h","title":"File sds_rec_play.h"},{"location":"SDS_API/sds__rec__play_8h.html#file-sds_rec_playh","text":"FileList > include > sds_rec_play.h Go to the source code of this file #include <stdint.h> The documentation for this class was generated from the following file sds/include/sds_rec_play.h","title":"File sds_rec_play.h"},{"location":"SDS_API/sds__rec__play_8h_source.html","text":"File sds_rec_play.h File List > include > sds_rec_play.h Go to the documentation of this file /* * Copyright (c) 2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDS_REC_PLAY_H #define SDS_REC_PLAY_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // ==== SDS Recorder and Player ==== typedef void *sdsRecPlayId_t; // Handle to SDS Recorder/Player stream // Function return codes #define SDS_REC_PLAY_OK (0) // Operation completed successfully #define SDS_REC_PLAY_ERROR (-1) // Operation failed #define SDS_REC_PLAY_ERROR_PARAMETER (-2) // Operation failed: parameter error #define SDS_REC_PLAY_ERROR_TIMEOUT (-3) // Operation failed: timeout error #define SDS_REC_PLAY_ERROR_IO (-4) // Operation failed: SDS I/O interface error #define SDS_REC_ERROR_NO_SPACE (-5) // Operation failed: insufficient space in stream buffer #define SDS_PLAY_ERROR_NO_DATA (-6) // Operation failed: insufficient data in stream buffer #define SDS_PLAY_EOS (-7) // End of stream reached // Event codes #define SDS_REC_PLAY_EVENT_ERROR_IO (1UL) // SDS I/O interface error #define SDS_REC_EVENT_ERROR_NO_SPACE (2UL) // sdsRecWrite() failed: insufficient space in stream buffer #define SDS_PLAY_EVENT_ERROR_NO_DATA (4UL) // sdsPlayRead() failed: insufficient data in stream buffer typedef void (*sdsRecPlayEvent_t) (sdsRecPlayId_t id, uint32_t event); int32_t sdsRecPlayInit (sdsRecPlayEvent_t event_cb); int32_t sdsRecPlayUninit (void); sdsRecPlayId_t sdsRecOpen (const char *name, void *buf, uint32_t buf_size); int32_t sdsRecClose (sdsRecPlayId_t id); int32_t sdsRecWrite (sdsRecPlayId_t id, uint32_t timestamp, const void *buf, uint32_t buf_size); sdsRecPlayId_t sdsPlayOpen (const char *name, void *buf, uint32_t buf_size); int32_t sdsPlayClose (sdsRecPlayId_t id); int32_t sdsPlayRead (sdsRecPlayId_t id, uint32_t *timestamp, void *buf, uint32_t buf_size); int32_t sdsPlayGetSize (sdsRecPlayId_t id); #ifdef __cplusplus } #endif #endif /* SDS_REC_PLAY_H */","title":"File sds_rec_play.h"},{"location":"SDS_API/sds__rec__play_8h_source.html#file-sds_rec_playh","text":"File List > include > sds_rec_play.h Go to the documentation of this file /* * Copyright (c) 2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDS_REC_PLAY_H #define SDS_REC_PLAY_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // ==== SDS Recorder and Player ==== typedef void *sdsRecPlayId_t; // Handle to SDS Recorder/Player stream // Function return codes #define SDS_REC_PLAY_OK (0) // Operation completed successfully #define SDS_REC_PLAY_ERROR (-1) // Operation failed #define SDS_REC_PLAY_ERROR_PARAMETER (-2) // Operation failed: parameter error #define SDS_REC_PLAY_ERROR_TIMEOUT (-3) // Operation failed: timeout error #define SDS_REC_PLAY_ERROR_IO (-4) // Operation failed: SDS I/O interface error #define SDS_REC_ERROR_NO_SPACE (-5) // Operation failed: insufficient space in stream buffer #define SDS_PLAY_ERROR_NO_DATA (-6) // Operation failed: insufficient data in stream buffer #define SDS_PLAY_EOS (-7) // End of stream reached // Event codes #define SDS_REC_PLAY_EVENT_ERROR_IO (1UL) // SDS I/O interface error #define SDS_REC_EVENT_ERROR_NO_SPACE (2UL) // sdsRecWrite() failed: insufficient space in stream buffer #define SDS_PLAY_EVENT_ERROR_NO_DATA (4UL) // sdsPlayRead() failed: insufficient data in stream buffer typedef void (*sdsRecPlayEvent_t) (sdsRecPlayId_t id, uint32_t event); int32_t sdsRecPlayInit (sdsRecPlayEvent_t event_cb); int32_t sdsRecPlayUninit (void); sdsRecPlayId_t sdsRecOpen (const char *name, void *buf, uint32_t buf_size); int32_t sdsRecClose (sdsRecPlayId_t id); int32_t sdsRecWrite (sdsRecPlayId_t id, uint32_t timestamp, const void *buf, uint32_t buf_size); sdsRecPlayId_t sdsPlayOpen (const char *name, void *buf, uint32_t buf_size); int32_t sdsPlayClose (sdsRecPlayId_t id); int32_t sdsPlayRead (sdsRecPlayId_t id, uint32_t *timestamp, void *buf, uint32_t buf_size); int32_t sdsPlayGetSize (sdsRecPlayId_t id); #ifdef __cplusplus } #endif #endif /* SDS_REC_PLAY_H */","title":"File sds_rec_play.h"},{"location":"SDS_API/sdsio_8h.html","text":"File sdsio.h FileList > include > sdsio.h Go to the source code of this file #include <stdint.h> Public Functions Type Name int32_t sdsioInit (void) Public Functions Documentation function sdsioInit int32_t sdsioInit ( void ) The documentation for this class was generated from the following file sds/include/sdsio.h","title":"File sdsio.h"},{"location":"SDS_API/sdsio_8h.html#file-sdsioh","text":"FileList > include > sdsio.h Go to the source code of this file #include <stdint.h>","title":"File sdsio.h"},{"location":"SDS_API/sdsio_8h.html#public-functions","text":"Type Name int32_t sdsioInit (void)","title":"Public Functions"},{"location":"SDS_API/sdsio_8h.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"SDS_API/sdsio_8h.html#function-sdsioinit","text":"int32_t sdsioInit ( void ) The documentation for this class was generated from the following file sds/include/sdsio.h","title":"function sdsioInit"},{"location":"SDS_API/sdsio_8h_source.html","text":"File sdsio.h File List > include > sdsio.h Go to the documentation of this file /* * Copyright (c) 2022-2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDSIO_H #define SDSIO_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // ==== Synchronous Data Stream Input/Output (SDS I/O) ==== typedef void *sdsioId_t; // Handle to SDS I/O stream // Open Mode typedef enum { sdsioModeRead = 0, // Open for read (binary) sdsioModeWrite = 1 // Open for write (binary) } sdsioMode_t; // Open mode (read/write) // Function return codes #define SDSIO_OK (0) // Operation completed successfully #define SDSIO_ERROR (-1) // Operation failed #define SDSIO_ERROR_PARAMETER (-2) // Operation failed: parameter error #define SDSIO_ERROR_TIMEOUT (-3) // Operation failed: timeout error #define SDSIO_ERROR_INTERFACE (-4) // Operation failed: SDS I/O interface error #define SDSIO_ERROR_NO_SERVER (-5) // Operation failed: no response from server #define SDSIO_EOS (-6) // End of stream reached int32_t sdsioInit (void); int32_t sdsioUninit (void); sdsioId_t sdsioOpen (const char *name, sdsioMode_t mode); int32_t sdsioClose (sdsioId_t id); int32_t sdsioWrite (sdsioId_t id, const void *buf, uint32_t buf_size); int32_t sdsioRead (sdsioId_t id, void *buf, uint32_t buf_size); #ifdef __cplusplus } #endif #endif /* SDSIO_H */","title":"File sdsio.h"},{"location":"SDS_API/sdsio_8h_source.html#file-sdsioh","text":"File List > include > sdsio.h Go to the documentation of this file /* * Copyright (c) 2022-2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDSIO_H #define SDSIO_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // ==== Synchronous Data Stream Input/Output (SDS I/O) ==== typedef void *sdsioId_t; // Handle to SDS I/O stream // Open Mode typedef enum { sdsioModeRead = 0, // Open for read (binary) sdsioModeWrite = 1 // Open for write (binary) } sdsioMode_t; // Open mode (read/write) // Function return codes #define SDSIO_OK (0) // Operation completed successfully #define SDSIO_ERROR (-1) // Operation failed #define SDSIO_ERROR_PARAMETER (-2) // Operation failed: parameter error #define SDSIO_ERROR_TIMEOUT (-3) // Operation failed: timeout error #define SDSIO_ERROR_INTERFACE (-4) // Operation failed: SDS I/O interface error #define SDSIO_ERROR_NO_SERVER (-5) // Operation failed: no response from server #define SDSIO_EOS (-6) // End of stream reached int32_t sdsioInit (void); int32_t sdsioUninit (void); sdsioId_t sdsioOpen (const char *name, sdsioMode_t mode); int32_t sdsioClose (sdsioId_t id); int32_t sdsioWrite (sdsioId_t id, const void *buf, uint32_t buf_size); int32_t sdsioRead (sdsioId_t id, void *buf, uint32_t buf_size); #ifdef __cplusplus } #endif #endif /* SDSIO_H */","title":"File sdsio.h"},{"location":"SDS_API/sdsio__client_8h.html","text":"File sdsio_client.h FileList > include > sdsio_client.h Go to the source code of this file #include <stdint.h> Classes Type Name struct header_t Public Functions Type Name int32_t sdsioClientInit (void) Initialize SDSIO Client and ping SDSIO Server to verify connection. int32_t sdsioClientReceive (uint8_t * buf, uint32_t buf_size) Receive data from SDSIO-Server. int32_t sdsioClientSend (const uint8_t * buf, uint32_t buf_size) Send data to SDSIO-Server. int32_t sdsioClientUninit (void) Un-Initialize SDSIO Client. Macros Type Name define SDSIO_CMD_CLOSE 2U define SDSIO_CMD_OPEN 1U define SDSIO_CMD_PING 5U define SDSIO_CMD_READ 4U define SDSIO_CMD_WRITE 3U Public Functions Documentation function sdsioClientInit Initialize SDSIO Client and ping SDSIO Server to verify connection. int32_t sdsioClientInit ( void ) Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes ) function sdsioClientReceive Receive data from SDSIO-Server. int32_t sdsioClientReceive ( uint8_t * buf, uint32_t buf_size ) Parameters: buf pointer to buffer for data to read buf_size buffer size in bytes Returns: number of bytes successfully received or a negative value on error (see Function Return Codes ) function sdsioClientSend Send data to SDSIO-Server. int32_t sdsioClientSend ( const uint8_t * buf, uint32_t buf_size ) Parameters: buf pointer to buffer with data to send buf_size buffer size in bytes Returns: number of bytes successfully sent or a negative value on error (see Function Return Codes ) function sdsioClientUninit Un-Initialize SDSIO Client. int32_t sdsioClientUninit ( void ) Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes ) Macro Definition Documentation define SDSIO_CMD_CLOSE #define SDSIO_CMD_CLOSE `2U` define SDSIO_CMD_OPEN #define SDSIO_CMD_OPEN `1U` define SDSIO_CMD_PING #define SDSIO_CMD_PING `5U` define SDSIO_CMD_READ #define SDSIO_CMD_READ `4U` define SDSIO_CMD_WRITE #define SDSIO_CMD_WRITE `3U` The documentation for this class was generated from the following file sds/include/sdsio_client.h","title":"File sdsio_client.h"},{"location":"SDS_API/sdsio__client_8h.html#file-sdsio_clienth","text":"FileList > include > sdsio_client.h Go to the source code of this file #include <stdint.h>","title":"File sdsio_client.h"},{"location":"SDS_API/sdsio__client_8h.html#classes","text":"Type Name struct header_t","title":"Classes"},{"location":"SDS_API/sdsio__client_8h.html#public-functions","text":"Type Name int32_t sdsioClientInit (void) Initialize SDSIO Client and ping SDSIO Server to verify connection. int32_t sdsioClientReceive (uint8_t * buf, uint32_t buf_size) Receive data from SDSIO-Server. int32_t sdsioClientSend (const uint8_t * buf, uint32_t buf_size) Send data to SDSIO-Server. int32_t sdsioClientUninit (void) Un-Initialize SDSIO Client.","title":"Public Functions"},{"location":"SDS_API/sdsio__client_8h.html#macros","text":"Type Name define SDSIO_CMD_CLOSE 2U define SDSIO_CMD_OPEN 1U define SDSIO_CMD_PING 5U define SDSIO_CMD_READ 4U define SDSIO_CMD_WRITE 3U","title":"Macros"},{"location":"SDS_API/sdsio__client_8h.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"SDS_API/sdsio__client_8h.html#function-sdsioclientinit","text":"Initialize SDSIO Client and ping SDSIO Server to verify connection. int32_t sdsioClientInit ( void ) Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsioClientInit"},{"location":"SDS_API/sdsio__client_8h.html#function-sdsioclientreceive","text":"Receive data from SDSIO-Server. int32_t sdsioClientReceive ( uint8_t * buf, uint32_t buf_size ) Parameters: buf pointer to buffer for data to read buf_size buffer size in bytes Returns: number of bytes successfully received or a negative value on error (see Function Return Codes )","title":"function sdsioClientReceive"},{"location":"SDS_API/sdsio__client_8h.html#function-sdsioclientsend","text":"Send data to SDSIO-Server. int32_t sdsioClientSend ( const uint8_t * buf, uint32_t buf_size ) Parameters: buf pointer to buffer with data to send buf_size buffer size in bytes Returns: number of bytes successfully sent or a negative value on error (see Function Return Codes )","title":"function sdsioClientSend"},{"location":"SDS_API/sdsio__client_8h.html#function-sdsioclientuninit","text":"Un-Initialize SDSIO Client. int32_t sdsioClientUninit ( void ) Returns: SDSIO_OK on success or a negative value on error (see Function Return Codes )","title":"function sdsioClientUninit"},{"location":"SDS_API/sdsio__client_8h.html#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"SDS_API/sdsio__client_8h.html#define-sdsio_cmd_close","text":"#define SDSIO_CMD_CLOSE `2U`","title":"define SDSIO_CMD_CLOSE"},{"location":"SDS_API/sdsio__client_8h.html#define-sdsio_cmd_open","text":"#define SDSIO_CMD_OPEN `1U`","title":"define SDSIO_CMD_OPEN"},{"location":"SDS_API/sdsio__client_8h.html#define-sdsio_cmd_ping","text":"#define SDSIO_CMD_PING `5U`","title":"define SDSIO_CMD_PING"},{"location":"SDS_API/sdsio__client_8h.html#define-sdsio_cmd_read","text":"#define SDSIO_CMD_READ `4U`","title":"define SDSIO_CMD_READ"},{"location":"SDS_API/sdsio__client_8h.html#define-sdsio_cmd_write","text":"#define SDSIO_CMD_WRITE `3U` The documentation for this class was generated from the following file sds/include/sdsio_client.h","title":"define SDSIO_CMD_WRITE"},{"location":"SDS_API/sdsio__client_8h_source.html","text":"File sdsio_client.h File List > include > sdsio_client.h Go to the documentation of this file /* * Copyright (c) 2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDSIO_CLIENT_H #define SDSIO_CLIENT_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // SDSIO Client works in a pair with SDSIO Server. Communication protocol is documented in the following link: // https://arm-software.github.io/SDS-Framework/main/theory/#sdsio-server-protocol // SDSIO header typedef struct { uint32_t command; uint32_t sdsio_id; uint32_t argument; uint32_t data_size; } header_t; // SDSIO Server Command IDs #define SDSIO_CMD_OPEN 1U #define SDSIO_CMD_CLOSE 2U #define SDSIO_CMD_WRITE 3U #define SDSIO_CMD_READ 4U #define SDSIO_CMD_PING 5U // Function prototypes int32_t sdsioClientInit (void); int32_t sdsioClientUninit (void); int32_t sdsioClientSend (const uint8_t *buf, uint32_t buf_size); int32_t sdsioClientReceive (uint8_t *buf, uint32_t buf_size); #ifdef __cplusplus } #endif #endif /* SDSIO_CLIENT_H */","title":"File sdsio_client.h"},{"location":"SDS_API/sdsio__client_8h_source.html#file-sdsio_clienth","text":"File List > include > sdsio_client.h Go to the documentation of this file /* * Copyright (c) 2025 Arm Limited. All rights reserved. * * SPDX-License-Identifier: Apache-2.0 * * Licensed under the Apache License, Version 2.0 (the License); you may * not use this file except in compliance with the License. * You may obtain a copy of the License at * * www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #ifndef SDSIO_CLIENT_H #define SDSIO_CLIENT_H #ifdef __cplusplus extern \"C\" { #endif #include <stdint.h> // SDSIO Client works in a pair with SDSIO Server. Communication protocol is documented in the following link: // https://arm-software.github.io/SDS-Framework/main/theory/#sdsio-server-protocol // SDSIO header typedef struct { uint32_t command; uint32_t sdsio_id; uint32_t argument; uint32_t data_size; } header_t; // SDSIO Server Command IDs #define SDSIO_CMD_OPEN 1U #define SDSIO_CMD_CLOSE 2U #define SDSIO_CMD_WRITE 3U #define SDSIO_CMD_READ 4U #define SDSIO_CMD_PING 5U // Function prototypes int32_t sdsioClientInit (void); int32_t sdsioClientUninit (void); int32_t sdsioClientSend (const uint8_t *buf, uint32_t buf_size); int32_t sdsioClientReceive (uint8_t *buf, uint32_t buf_size); #ifdef __cplusplus } #endif #endif /* SDSIO_CLIENT_H */","title":"File sdsio_client.h"},{"location":"SDS_API/sds_8txt.html","text":"File sds.txt FileList > sds.txt Go to the source code of this file The documentation for this class was generated from the following file sds/include/sds.txt","title":"File sds.txt"},{"location":"SDS_API/sds_8txt.html#file-sdstxt","text":"FileList > sds.txt Go to the source code of this file The documentation for this class was generated from the following file sds/include/sds.txt","title":"File sds.txt"},{"location":"SDS_API/sds_8txt_source.html","text":"File sds.txt File List > sds.txt Go to the documentation of this file /*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/ // end group SDS_Buffer /*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/ int32_t sdsioInit (void); // end group SDS_IO_Interface /*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/ // end group SDS_Recorder_Player","title":"File sds.txt"},{"location":"SDS_API/sds_8txt_source.html#file-sdstxt","text":"File List > sds.txt Go to the documentation of this file /*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/ // end group SDS_Buffer /*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/ int32_t sdsioInit (void); // end group SDS_IO_Interface /*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/ // end group SDS_Recorder_Player","title":"File sds.txt"},{"location":"SDS_API/namespaces.html","text":"Namespace List Here is a list of all namespaces with brief descriptions:","title":"Namespace List"},{"location":"SDS_API/namespaces.html#namespace-list","text":"Here is a list of all namespaces with brief descriptions:","title":"Namespace List"},{"location":"SDS_API/classes.html","text":"Class Index h header_t","title":"Class Index"},{"location":"SDS_API/classes.html#class-index","text":"","title":"Class Index"},{"location":"SDS_API/classes.html#h","text":"header_t","title":"h"},{"location":"SDS_API/hierarchy.html","text":"Class Hierarchy This inheritance list is sorted roughly, but not completely, alphabetically: struct header_t","title":"Class Hierarchy"},{"location":"SDS_API/hierarchy.html#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: struct header_t","title":"Class Hierarchy"},{"location":"SDS_API/modules.html","text":"Modules Here is a list of all modules: SDS Circular Buffer sds_buffer.h : SDS circular buffer handling for data streams Event Codes SDS Buffer Event Codes. Function Return Codes SDS Buffer Function Return Codes. SDS I/O Interface sdsio.h : SDS I/O Interface for data streams Function Return Codes SDS I/O Function Return Codes. SDS Recorder and Player sds_rec_play.h : SDS Recorder and Player for writing and reading SDS files via communication or file I/O interface. Event Codes SDS Recorder and Player Event Codes. Function Return Codes SDS Recorder and Player Function Return Codes.","title":"API Modules"},{"location":"SDS_API/modules.html#modules","text":"Here is a list of all modules: SDS Circular Buffer sds_buffer.h : SDS circular buffer handling for data streams Event Codes SDS Buffer Event Codes. Function Return Codes SDS Buffer Function Return Codes. SDS I/O Interface sdsio.h : SDS I/O Interface for data streams Function Return Codes SDS I/O Function Return Codes. SDS Recorder and Player sds_rec_play.h : SDS Recorder and Player for writing and reading SDS files via communication or file I/O interface. Event Codes SDS Recorder and Player Event Codes. Function Return Codes SDS Recorder and Player Function Return Codes.","title":"Modules"},{"location":"SDS_API/pages.html","text":"Related Pages Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"SDS_API/pages.html#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"SDS_API/class_members.html","text":"Class Members a argument ( header_t ) c command ( header_t ) d data_size ( header_t ) s sdsio_id ( header_t )","title":"Class Members"},{"location":"SDS_API/class_members.html#class-members","text":"","title":"Class Members"},{"location":"SDS_API/class_members.html#a","text":"argument ( header_t )","title":"a"},{"location":"SDS_API/class_members.html#c","text":"command ( header_t )","title":"c"},{"location":"SDS_API/class_members.html#d","text":"data_size ( header_t )","title":"d"},{"location":"SDS_API/class_members.html#s","text":"sdsio_id ( header_t )","title":"s"},{"location":"SDS_API/class_member_functions.html","text":"Class Member Functions Nothing related to Class Member Functions found.","title":"Class Member Functions"},{"location":"SDS_API/class_member_functions.html#class-member-functions","text":"Nothing related to Class Member Functions found.","title":"Class Member Functions"},{"location":"SDS_API/class_member_variables.html","text":"Class Member Variables a argument ( header_t ) c command ( header_t ) d data_size ( header_t ) s sdsio_id ( header_t )","title":"Class Member Variables"},{"location":"SDS_API/class_member_variables.html#class-member-variables","text":"","title":"Class Member Variables"},{"location":"SDS_API/class_member_variables.html#a","text":"argument ( header_t )","title":"a"},{"location":"SDS_API/class_member_variables.html#c","text":"command ( header_t )","title":"c"},{"location":"SDS_API/class_member_variables.html#d","text":"data_size ( header_t )","title":"d"},{"location":"SDS_API/class_member_variables.html#s","text":"sdsio_id ( header_t )","title":"s"},{"location":"SDS_API/class_member_typedefs.html","text":"Class Member Typedefs Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"SDS_API/class_member_typedefs.html#class-member-typedefs","text":"Nothing related to Class Member Typedefs found.","title":"Class Member Typedefs"},{"location":"SDS_API/class_member_enums.html","text":"Class Member Enums Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"SDS_API/class_member_enums.html#class-member-enums","text":"Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"SDS_API/namespace_members.html","text":"Namespace Members Nothing related to Namespace Members found.","title":"Namespace Members"},{"location":"SDS_API/namespace_members.html#namespace-members","text":"Nothing related to Namespace Members found.","title":"Namespace Members"},{"location":"SDS_API/namespace_member_functions.html","text":"Namespace Member Functions Nothing related to Namespace Member Functions found.","title":"Namespace Member Functions"},{"location":"SDS_API/namespace_member_functions.html#namespace-member-functions","text":"Nothing related to Namespace Member Functions found.","title":"Namespace Member Functions"},{"location":"SDS_API/namespace_member_variables.html","text":"Namespace Member Variables Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"SDS_API/namespace_member_variables.html#namespace-member-variables","text":"Nothing related to Namespace Member Variables found.","title":"Namespace Member Variables"},{"location":"SDS_API/namespace_member_typedefs.html","text":"Namespace Member Typedefs Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"SDS_API/namespace_member_typedefs.html#namespace-member-typedefs","text":"Nothing related to Namespace Member Typedefs found.","title":"Namespace Member Typedefs"},{"location":"SDS_API/namespace_member_enums.html","text":"Namespace Member Enums Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"SDS_API/namespace_member_enums.html#namespace-member-enums","text":"Nothing related to Namespace Member Enums found.","title":"Namespace Member Enums"},{"location":"SDS_API/functions.html","text":"Functions s sdsioInit ( sdsio.h ) sdsioClientInit ( sdsio_client.h ) sdsioClientReceive ( sdsio_client.h ) sdsioClientSend ( sdsio_client.h ) sdsioClientUninit ( sdsio_client.h )","title":"Functions"},{"location":"SDS_API/functions.html#functions","text":"","title":"Functions"},{"location":"SDS_API/functions.html#s","text":"sdsioInit ( sdsio.h ) sdsioClientInit ( sdsio_client.h ) sdsioClientReceive ( sdsio_client.h ) sdsioClientSend ( sdsio_client.h ) sdsioClientUninit ( sdsio_client.h )","title":"s"},{"location":"SDS_API/macros.html","text":"Macros s SDSIO_CMD_CLOSE ( sdsio_client.h ) SDSIO_CMD_OPEN ( sdsio_client.h ) SDSIO_CMD_PING ( sdsio_client.h ) SDSIO_CMD_READ ( sdsio_client.h ) SDSIO_CMD_WRITE ( sdsio_client.h )","title":"Macros"},{"location":"SDS_API/macros.html#macros","text":"","title":"Macros"},{"location":"SDS_API/macros.html#s","text":"SDSIO_CMD_CLOSE ( sdsio_client.h ) SDSIO_CMD_OPEN ( sdsio_client.h ) SDSIO_CMD_PING ( sdsio_client.h ) SDSIO_CMD_READ ( sdsio_client.h ) SDSIO_CMD_WRITE ( sdsio_client.h )","title":"s"},{"location":"SDS_API/variables.html","text":"Variables Nothing related to Variables found.","title":"Variables"},{"location":"SDS_API/variables.html#variables","text":"Nothing related to Variables found.","title":"Variables"},{"location":"SDS_API/links.html","text":"Related Pages Modules Class List Namespace ListNamespace List Namespace Members Namespace Member Functions Namespace Member Variables Namespace Member Typedefs Namespace Member Enumerations Class Index Class Hierarchy Class Members Class Member Functions Class Member Variables Class Member Typedefs Class Member Enumerations Files File Variables File Functions File Macros","title":"Links"}]}