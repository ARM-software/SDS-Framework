/*
 * Copyright (c) 2025 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stddef.h>
#include <string.h>
#include "cmsis_os2.h"
#include "sds_algorithm_config.h"
#include "sds_data_in.h"


// Raw sensor data sample structure
typedef struct {
  uint16_t x;
  uint16_t y;
  uint16_t z;
} accelerometer_sample_t;


/**
  \fn           int32_t InitInputData (void)
  \brief        Initialize system for acquiring input data.
  \return       0 on success; -1 on error
*/
int32_t InitInputData (void) {

  // No initialization necessary as test data is generated by code

  return 0;
}

/**
  \fn           int32_t GetInputData (uint8_t *buf, uint32_t max_len)
  \brief        Get input data block as required for algorithm under test.
  \details      Size of this block has to match size expected by algorithm under test.
  \param[out]   buf             pointer to memory buffer for acquiring input data
  \param[in]    max_len         maximum number of bytes of input data to acquire
  \return       number of data bytes returned; -1 on error
*/
int32_t GetInputData (uint8_t *buf, uint32_t max_len) {
  static uint16_t index;
  static uint32_t interval_time = 0U;
         accelerometer_sample_t *ptr_acc_sample;
         uint16_t val;
         int32_t  i;

  // Check input parameters
  if ((buf == NULL) || (max_len == 0U)) {
    return -1;
  }

  // Check if buffer can fit expected data
  if (max_len < SDS_ALGO_DATA_IN_BLOCK_SIZE) {
    return -1;
  }

  if (interval_time == 0U) {
    // Read initial tick count for further timing reference
    interval_time = osKernelGetTickCount();
  }

  // Generate test data in the `buf`
  ptr_acc_sample = (accelerometer_sample_t *)buf;
  for (i = 0; i < (SDS_ALGO_DATA_IN_BLOCK_SIZE / 6); i++) {
    val = (index + i) % 3000;
    ptr_acc_sample->x = val;
    val = (val + 250) % 3000;
    ptr_acc_sample->y = 2999 - val;
    val = (val + 300) % 3000;
    ptr_acc_sample->z = (val < 1500) ? val : (2999 - val);
    ptr_acc_sample   += 1;
  }
  index = (index + i) % 3000;

  // Wait for time interval simulating real world sensor data acquisition
  interval_time += SDS_ALGO_TEST_INTERVAL;
  osDelayUntil(interval_time);

  return SDS_ALGO_DATA_IN_BLOCK_SIZE;
}
